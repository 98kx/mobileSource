/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2001
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 * meta.h
 *
 * Project:
 * --------
 *   META
 *
 * Description:
 * ------------
 *   This module contains the definitions for using META_DLL.dll.
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 *           HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *==============================================================================
 *******************************************************************************/
#ifndef META_DLL_H
#define META_DLL_H


#include "brom.h"




#ifdef __cplusplus
extern "C" {
#endif



//--------------------------------------------------------------------------//
//  META General                                                            //
//--------------------------------------------------------------------------//

#define META_DEFAULT_SHORT_TIMEOUT	1000
#define META_DEFAULT_MID_TIMEOUT	3000
#define META_DEFAULT_LONG_TIMEOUT	5000

//-----------------------------------------------------//
//  META General: data structure definition            //
//-----------------------------------------------------//
typedef enum
{
	// META_DLL received a corrupted frame
	META_CNF_FRAME_ERROR = 0,

	// META_DLL received a confirm or indication from target,
	// but there is not corresponding call back function
	// installed for this confirm or indication.
	META_CNF_NO_CALLBACK = 1,

	// META_DLL received a corrupted primitive.
	META_CNF_PRIMITIVE_ERROR = 2,

	// META_DLL received a confirm or indication from
	// target, but there is no sufficient memory to process.
	META_CNF_NO_MEMORY = 3,

	// META_DLL retrieved a callback function, however,
	// the user input arguments are invalid.
	META_CNF_CALLBACK_PARAMETER_ERROR = 4,

	// META_DLL received a confirm with peer msg, however,
	// the peer msg is corrupted.
	META_CNF_PEER_MSG_ERROR = 5,

	// META_DLL received a confirm and successfully executed
	// the callback function.
	META_CNF_OK = 6
} META_CNF_ERR_CODE;

// The magic value to stop usb enumerate process 
#define ENUM_USB_STOP	9876
#define ENUM_ANY_STOP   9876

typedef enum
{
	META_SUCCESS = 0
	,META_FAILED
	,META_COMM_FAIL
	,META_NORESPONSE
	,META_BUFFER_LEN
	,META_FILE_BAD
	,META_LID_INVALID
	,META_INTERNAL_DB_ERR
	,META_NO_MEMORY
	,META_INVALID_ARGUMENTS
	,META_TIMEOUT                // 10
	,META_BUSY
	,META_INVALID_HANDLE
	,META_FAT_ERROR
	,META_FAT_DISK_FULL
	,META_FAT_ROOT_DIR_FULL
	,META_FAT_INVALID_FILENAME
	,META_FAT_INVALID_FILE_HANDLE
	,META_FAT_FILE_NOT_FOUND
	,META_FAT_DRIVE_NOT_FOUND
	,META_FAT_PATH_NOT_FOUND        // 20
	,META_FAT_ACCESS_DENIED
	,META_FAT_TOO_MANY_FILES
	,META_INCORRECT_TARGET_VER
	,META_COM_ERROR
	,META_BROM_CMD_ERROR
	,META_INCORRECT_BBCHIP_TYPE
	,META_BROM_ERROR
	,META_STOP_BOOTUP_PROCEDURE
	,META_CANCEL
	,META_CCT_NOT_IMPORT_PROFILE     //30
	,META_CCT_INVALID_SENSOR_ID
	,META_CCT_TGT_NO_MEM_FOR_SINGLE_SHOT
	,META_CCT_TGT_NO_MEM_FOR_MULTI_SHOT
	,META_FUNC_NOT_IMPLEMENT_YET
	,META_CCT_NOT_IMPLEMENT_YET = META_FUNC_NOT_IMPLEMENT_YET
	,META_CCT_PREVIEW_ALREADY_STARTED
	,META_CCT_PREVIEW_ALREADY_STOPPED
	,META_CCT_READ_REG_NO_CNF
	,META_CCT_WRITE_REG_NO_CNF
	,META_CCT_TGT_ABORT_IMAGE_SENDING     
	,META_CCT_READ_ONLY_REGISTER          // 40
	,META_CCT_LOAD_FROM_NVRAM_FAIL
	,META_CCT_SAVE_TO_NVRAM_FAIL
	,META_CCT_AE_INVALID_EC_LEVEL
	,META_CCT_AE_INVALID_EC_STEP
	,META_CCT_AE_ALREADY_ENABLED
	,META_CCT_AE_ALREADY_DISABLED
	,META_CCT_WB_INVALID_INDEX
	,META_CCT_NO_TGT_SENSOR_MATCH_IN_PROFILE
	,META_CCT_IMAGE_SENDING_FAME_NUM_ERROR    
	,META_CCT_AE_IS_NOT_DISABLED           // 50
	,META_FAT_APP_QUOTA_FULL
	,META_IMEI_CD_ERROR
	,META_RFID_MISMATCH
	,META_NVRAM_DB_IS_NOT_LOADED_YET
	,META_CCT_ERR_CAPTURE_WIDTH_HEIGHT_TOO_SMALL
	,META_WAIT_FOR_TARGET_READY_TIMEOUT
	,META_CCT_ERR_SENSOR_ENG_SET_INVALID_VALUE
	,META_CCT_ERR_SENSOR_ENG_GROUP_NOT_EXIST
	,META_CCT_NO_TGT_ISP_MATCH_IN_PROFILE       
	,META_CCT_TGT_ISP_SUPPORT_NOT_DEFINED        //60
	,META_CCT_ERR_SENSOR_ENG_ITEM_NOT_EXIST
	,META_CCT_ERR_INVALID_COMPENSATION_MODE
	,META_CCT_ERR_USB_COM_NOT_READY
	,META_CCT_DEFECTPIXEL_CAL_UNDER_PROCESSING
	,META_CCT_ERR_DEFECTPIXEL_CAL_NO_MEM
	,META_CCT_ERR_TOO_MANY_DEFECT_PIXEL
	,META_CCT_ERR_CAPTURE_JPEG_FAIL
	,META_CCT_ERR_CAPTURE_JPEG_TIMEOUT
	,META_CCT_ERR_AF_FAIL                       
	,META_CCT_ERR_AF_TIMEOUT                    // 70
	,META_CCT_ERR_AF_LENS_OFFSET_CAL_FAIL
	,META_CCT_ERR_PREVIEW_MUST_ENABLE
	,META_CCT_ERR_UNSUPPORT_CAPTURE_FORMAT
	,META_CCT_ERR_EXCEED_MAX_DEFECT_PIXEL
	,META_ERR_EXCEED_MAX_PEER_BUF_SIZE
	,META_CCT_ERR_INVALID_WIDTH_FACTOR
	,META_BROM_SECURITY_CHECK_FAIL
	,META_CCT_ERR_PREVIEW_MUST_DISABLE
	,META_MAUI_DB_INCONSISTENT                 
	,META_FAT_FILEPATH_TOO_LONG                // 80
	,META_FAT_RESTRICTED_FILEPATH
	,META_FAT_DIR_NOT_EXIST
	,META_FAT_DISK_SPACE_IS_NOT_ENOUGH
	,META_TDMB_ERR_BAND_NOT_EXIST
	,META_TDMB_ERR_FREQ_NOT_EXIST
	,META_TDMB_ERR_ENSM_NOT_EXIST
	,META_TDMB_ERR_SERV_NOT_EXIST
	,META_TDMB_ERR_SUB_CHAN_NOT_EXIST
	,META_TDMB_ERR_DEMOD_STATE                
	//,META_PERMISSION_DENIED : not used                
	,META_ENUMERATE_USB_FAIL                    // 90
    ,META_STOP_ENUM_USB_PROCEDURE
    //----------------[TH] for CCT 6238--------------------------
    ,META_CCT_6238_AE_ALREADY_ENABLED
	,META_CCT_6238_AE_ALREADY_DISABLED
	,META_CCT_6238_AE_IS_NOT_DISABLED
    ,META_CCT_6238_ISP_FLASHLIGHT_LINEARITY_PRESTROBE_FAIL
    //-----------------------------------------------------------
	//----------------[for backup and restore calibration data] ----------
	,META_MISC_TARGET_LOAD_NEED_TO_BE_PATCHED
	,META_MISC_INI_FILE_SETTINGS_WRONG                 // can not find files or not enough!
	,META_MISC_FAIL_TO_READ_IMEI
	,META_MISC_FAIL_TO_BACKUP_FILE
	,META_MISC_FAIL_TO_WRITE_BACKUP_RESULT      // 100
	,META_MISC_FAIL_TO_GET_NVRAM_FOLDER_PATH           
	,META_MISC_FAIL_TO_GET_NVRAM_MUST_LIST
	,META_STOP_CURRENT_PROCEDURE
	,META_MISC_CUSTOMIZED_NVRAM_ERROR
	,META_MISC_FOLDER_EMPTY_CHECKING_FAIL 
    ,META_MISC_TOO_MANY_BACKUP_RESULT_FILE             
	,META_MISC_TOO_MANY_RESTORE_RESULT_FILE
	,META_MISC_RESTORE_RESULT_FILE_NOT_EXIST
	,META_MISC_RESTORE_RESULT_FILE_INCOMPLETE
	,META_FAIL_TO_CELAR_ALL_IN_BACUP_FOLDER            // 110
	,META_MISC_BACKUP_RESULT_FILE_NOT_EXIST            // [Restore only]    
	,META_MISC_BACKUP_RESULT_FILE_INCOMPLETE           // [Restore only] 
	,META_MISC_IMEI_MISMATCH                           // [Restore only]    
	,META_MISC_SML_FILE_VERIFY_FAIL                    // [Restore only]: the SML file is invalid for this phone
	,META_MISC_BACKUP_RESULT_NOT_ENOUGH_FOR_NEW_LOAD   // [Restore only]: new load has more LIDs need to be backuped
	,META_MISC_FAIL_TO_RESTORE_FILE                    // [Restore only]    
	,META_MISC_FAIL_TO_WRITE_RESTORE_RESULT            // [Restore only]
	,META_MISC_USE_WRONG_API_FOR_NEW_LOAD
    ,META_MISC_QUERY_TARGET_CAPABILITY_FAIL
	,META_MISC_INI_SETTINGS_ERR_IN_NVRAM_SEC            // 120
	,META_MISC_INI_SETTINGS_ERR_IN_TARGET_SEC
	,META_MISC_INI_SETTINGS_ERR_IN_PC_SEC 
    ,META_MISC_NO_FILES_NEED_TO_BE_UPLOAD
	,META_FAT_ACTION_NOT_SUPPORT
    ,META_CCT_DUAL_UNSOPPORT_DUAL_CAMERA_IN_TARGET 
	,META_CCT_DUAL_SET_MAIN_SUB_SENSOR_FAIL 
	,META_CCT_DUAL_GET_CAMERA_PARA_TABLE_TAIL
	,META_CCT_DUAL_GET_SENSOR_PREFIX_NAME_TAIL
	,META_CCT_DUAL_ERR_DETECT_SENSOR_ID_FAIL
	,META_CCT_ERR_DETECT_SENSOR_ID_FAIL                 // 130
	,META_CCT_ERR_YUV_SENSOR_NOT_SUPPORT
	,META_CCT_DUAL_GET_LENS_PREFIX_NAME_TAIL
    ,META_MISC_EMPTY_UPLOADFILES_AND_IMEI_SEC
	,META_MISC_INI_SETTINGS_ERR_IN_MORE_SEC              
	,META_MISC_INI_SETTINGS_ERR_IN_DELETE_SEC
	,META_MISC_CHECK_TARGET_NVRAM_FILES_FAIL
    ,META_MISC_FAIL_TO_GET_NVRAM_FOLDER_AMOUNT
	,META_AUDIO_CHECK_WAVE_FILE_FAIL
	,META_LAST_RESULT
} META_RESULT;

typedef enum  {
	META_BAUD2400 = 0,
	META_BAUD4800,
	META_BAUD9600,
	META_BAUD14400,
	META_BAUD19200,
	META_BAUD57600,   // 5
	META_BAUD115200,
	META_BAUD230400,
	META_BAUD460800,
	META_BAUD921600,
	META_BAUD1500000,            //10
	META_BAUD_END = 0xFF
} META_COMM_BAUDRATE;

typedef enum {
	META_NO_FLOWCTRL = 0,	// no flow control
	META_SW_FLOWCTRL,		// enable S/W flow control
	META_FLOWCTRL_END
} META_FLOWCTRL;

typedef struct {
	char	BB_CHIP[64];	// BaseBand chip version
	char	ECO_VER[4];		// ECO version
	char	DSP_FW[64];		// DSP firmware version
	char	DSP_PATCH[64];	// DSP patch version
	char	SW_VER[64];		// S/W version
	char	HW_VER[64];		// H/W board version
	char	MELODY_VER[64];	// Melody version
} VerInfo_Cnf;

typedef struct
{
	unsigned short      com_port_list[255];   
	unsigned short      com_port_num;
	unsigned int		ms_connect_timeout; // [META] META enumerate port timeout value 

}META_Enumerate_USB_Req;

typedef struct {
	int 				com_port;
	META_COMM_BAUDRATE  baudrate[12];		// [META] META stage baudrate polling array, it must end with META_BAUD_END. 
	META_FLOWCTRL  		flowctrl;			// [META] META stage uart flow control type. 
	BOOT_META_ARG		boot_meta_arg;		// [BootROM] please refer to brom.h 
	unsigned int		ms_connect_timeout; // [META] META stage sync timeout value (after BootROM negotiation pass) 
} META_Connect_Req;

typedef struct
{
	unsigned int m_u4TargetMainVersion;  
	unsigned int m_u4TargetMinorVersion;
	unsigned int m_u4TargetBuildNum;   

}META_VER_REQUIRED_BY_TARGET;

typedef struct {
	META_COMM_BAUDRATE  final_baudrate;					// [META] Detected META stage baudrate.     
	unsigned int		meta_ver_required_by_target;	// [META] Target required META_DLL version.  ==> always return 0
	BOOT_RESULT			boot_result;					// [BootROM] boot-up result. 
	STATUS_E			boot_meta_ret;					// [BROM_DLL] The return code of Boot_META function. 
	META_VER_REQUIRED_BY_TARGET   m_rTargetVer;         // [META] Target required META_DLL version.
} META_Connect_Report;

typedef struct {
	int 				com_port;
	BOOT_META_ARG		boot_meta_arg;		// [BootROM] please refer to brom.h 
	unsigned int		ms_connect_timeout; // [META] META stage sync timeout value (after BootROM negotiation pass) 
} META_ConnectByUSB_Req;

typedef struct {
	unsigned int		meta_ver_required_by_target;	// [META] Target required META_DLL version.  ==> always return 0
	BOOT_RESULT			boot_result;					// [BootROM] boot-up result. 
	STATUS_E			boot_meta_ret;					// [BROM_DLL] The return code of Boot_META function. 
	META_VER_REQUIRED_BY_TARGET   m_rTargetVer;         // [META] Target required META_DLL version.
} META_ConnectByUSB_Report;

typedef struct {
	int 				com_port;
	META_COMM_BAUDRATE  baudrate[11];		// [META] META stage baudrate polling array, it must end with META_BAUD_END. 
	META_FLOWCTRL  		flowctrl;			// [META] META stage uart flow control type. 
	unsigned int		ms_connect_timeout; // [META] META stage sync timeout value (after BootROM negotiation pass) 
} META_ConnectInMETA_Req;



typedef struct {
	META_COMM_BAUDRATE            final_baudrate;					// [META] Detected META stage baudrate. 
	unsigned int		          meta_ver_required_by_target;	// [META] Target required META_DLL version.  ==> always return 0
	META_VER_REQUIRED_BY_TARGET   m_rTargetVer;         // [META] Target required META_DLL version.
} META_ConnectInMETA_Report;



//-----------------------------------------------------//
//  META General: callback function definition         //
//-----------------------------------------------------//
typedef void (__stdcall *META_Error_CallBack)(const META_CNF_ERR_CODE  mr);
typedef void (__stdcall *META_SysTrace_CallBack)(const char *sys_trace);
typedef void (__stdcall *META_GET_VERSION_INFO_CNF)(const VerInfo_Cnf  *cnf, const short token, void *usrData);

//-----------------------------------------------------//
//  META for CTI                                       //
//-----------------------------------------------------//
typedef enum {
	 CTI_OK = 0
	,CTI_MISSING_HEADER
	,CTI_CORRUPTED_FAME
	,CTI_EXCEED_LEN
} CTI_RET_ENUM;

typedef void (__stdcall *META_CTI_CallBack)(CTI_RET_ENUM  ret, const int size, const unsigned char *data, void *param);
META_RESULT  __stdcall META_CTI_SendPacketCmd(const unsigned char *pPayLoadBuffer, int nPayloadLength);
META_RESULT  __stdcall META_CTI_SendPacketCmd_r(const int meta_handle, const unsigned char *pPayLoadBuffer, int nPayloadLength);
META_RESULT  __stdcall META_CTI_SetPacketCallback(META_CTI_CallBack  pCBFunc, void* param);
META_RESULT  __stdcall META_CTI_SetPacketCallback_r(const int meta_handle, META_CTI_CallBack  pCBFunc, void* param);

//-----------------------------------------------------//
//  Switch TST message format                          //
//-----------------------------------------------------//
typedef enum {
	META_TST_MSG_2G = 0,
	META_TST_MSG_3G
} META_TST_MSG_FORMAT;

META_RESULT  __stdcall META_SetTstMsgFormat(META_TST_MSG_FORMAT  msg_fmt);
META_RESULT  __stdcall META_SetTstMsgFormat_r(const int meta_handle, META_TST_MSG_FORMAT  msg_fmt);

//-----------------------------------------------------//
//  META Debug: exported debug function definition     //
//-----------------------------------------------------//
META_RESULT  __stdcall META_DebugOn();
META_RESULT  __stdcall META_DebugOn_With_FilePath(const char* filepath);
META_RESULT  __stdcall META_DebugOn_ex(const int meta_handle);
META_RESULT  __stdcall META_DebugOn_ex2(const int meta_handle, char *path);
META_RESULT  __stdcall META_DebugOff();
META_RESULT  __stdcall META_DebugClear();

//-----------------------------------------------------//
//  META UnitTest                                      //
//-----------------------------------------------------//

typedef struct {
	unsigned int	m_TestCaseID;
	const char *	m_pDescription;
} META_UT_TestCaseID_T;

void __stdcall META_QueryTestCase(META_UT_TestCaseID_T  **ppTestCase, unsigned int  *pTestCaseCount);
void __stdcall META_UnitTest(const unsigned int  *p_TestCaseID_Array, unsigned int  TestCaseCount);

//-----------------------------------------------------//
//  META General: exported function definition         //
//-----------------------------------------------------//

#define     FT_MT_UNKNOWN  0
#define     FT_MT6305  1
#define     FT_MT6318  2
#define     FT_MT6326  3
 
typedef struct {
	unsigned char	id;
} PMIC_ID;
typedef struct {
	unsigned int	pcl;
} RF_GetITC_PCL;
// General 
void  __stdcall META_GetDLLVer(unsigned int *major_ver, unsigned int *minor_ver, unsigned int *build_num, unsigned int *patch_num);
void  __stdcall META_GetDLLInfo(const char **pp_version, const char **pp_release_type, const char **pp_build_date, const char **pp_load_path);
void  __stdcall META_Cancel(const short token);
void  __stdcall META_Cancel_r(const int meta_handle, const short token);
void  __stdcall META_CancelAllBlockingCall(void);
void  __stdcall META_CancelAllBlockingCall_r(const int meta_handle);
META_RESULT  __stdcall META_QueryIfFunctionSupportedByTarget(unsigned int ms_timeout, const char *query_func_name);
META_RESULT  __stdcall META_QueryIfFunctionSupportedByTarget_r(const int meta_handle, unsigned int ms_timeout, const char *query_func_name);
META_RESULT  __stdcall META_QueryIfTargetSupportISP(unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfTargetSupportISP_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfTargetSupportAcoustic16level(unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfTargetSupportAcoustic16level_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfTargetSupportAudioParam45Tap(unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfTargetSupportAudioParam45Tap_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfTargetIsLowCostSingleBankFlash(unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfTargetIsLowCostSingleBankFlash_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryPMICID(unsigned int  ms_timeout, PMIC_ID  *cnf);
META_RESULT  __stdcall META_QueryPMICID_r(const int meta_handle, unsigned int  ms_timeout, PMIC_ID  *cnf);
META_RESULT  __stdcall META_BTPowerOn(unsigned int ms_timeout);
META_RESULT  __stdcall META_BTPowerOn_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfTargetSupportWifiALC(unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfTargetSupportWifiALC_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryITC_PCL(unsigned int  ms_timeout, RF_GetITC_PCL  *cnf);
META_RESULT  __stdcall META_QueryITC_PCL_r(const int meta_handle, unsigned int  ms_timeout, RF_GetITC_PCL  *cnf);
META_RESULT  __stdcall META_QueryIfTargetSupportDRC(unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfTargetSupportDRC_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfBTPowerOn(unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfBTPowerOn_r(const int meta_handle, unsigned int ms_timeout);

//-----------------------------------------------------//
//  UTILITY--ENABLE WATCHDOG				           //
//-----------------------------------------------------//
#define GPIO_DEV_LED_MAINLCD 0
//#define GPIO_DEV_LED_SUBLCD 1

typedef struct {
	unsigned int	ms_timeout_interval;
} FtWatchDog;

typedef struct {
	unsigned char		led_light_level;
} FtLEDLevel;

typedef struct {
	unsigned char		lcd_type;
	unsigned char		lcd_light_level;
} FtLCDLevel;

typedef struct {
	unsigned char		onoff;
} FtVibratorOnOff;

typedef struct {
	unsigned char		m_rtc_sec;    /* seconds after the minute   - [0,59]  */
	unsigned char		m_rtc_min;    /* minutes after the hour     - [0,59]  */
	unsigned char		m_rtc_hour;   /* hours after the midnight   - [0,23]  */
	unsigned char		m_rtc_day;    /* day of the month           - [1,31]  */
	unsigned char		m_rtc_mon;    /* months 		               - [1,12] */
	unsigned char		m_rtc_wday;   /* days in a week 		      - [1,7] */
	unsigned char		m_rtc_year; 
} T_Rtc;

META_RESULT  __stdcall META_EnableWatchDogTimer(unsigned int ms_timeout, FtWatchDog *req);
META_RESULT  __stdcall META_EnableWatchDogTimer_r(const int meta_handle, unsigned int ms_timeout, FtWatchDog *req);

META_RESULT  __stdcall META_SetLEDLightLevel(unsigned int ms_timeout, FtLEDLevel *req);
META_RESULT  __stdcall META_SetLEDLightLevel_r(const int meta_handle, unsigned int ms_timeout, FtLEDLevel *req);

META_RESULT  __stdcall META_SetVibratorOnOff(unsigned int ms_timeout, FtVibratorOnOff *req);
META_RESULT  __stdcall META_SetVibratorOnOff_r(const int meta_handle, unsigned int ms_timeout, FtVibratorOnOff *req);

META_RESULT  __stdcall META_QueryLocalTime(unsigned int  ms_timeout, T_Rtc  *cnf);
META_RESULT  __stdcall META_QueryLocalTime_r(const int meta_handle, unsigned int  ms_timeout, T_Rtc  *cnf); 

META_RESULT  __stdcall META_SetMainSubLCDLightLevel(unsigned int ms_timeout, FtLCDLevel *req);
META_RESULT  __stdcall META_SetMainSubLCDLightLevel_r(const int meta_handle, unsigned int ms_timeout, FtLCDLevel *req);


// timer-related APIs
META_RESULT  __stdcall META_StartTimer();
META_RESULT  __stdcall META_StartTimer_r(const int meta_handle);
META_RESULT  __stdcall META_StopTimer();
META_RESULT  __stdcall META_StopTimer_r(const int meta_handle);
META_RESULT __stdcall META_GetProcessTime(unsigned int  *pProcessTime, unsigned short *pNumAPIs);
META_RESULT __stdcall META_GetProcessTime_r(const int meta_handle, unsigned int *pProcessTime, unsigned short *pNumAPIs);



const char * __stdcall META_GetErrorString(META_RESULT  ErrCode);
const char * __stdcall META_BaudrateEnumToName(META_COMM_BAUDRATE  baudrate);

// Initialization 
META_RESULT  __stdcall META_GetAvailableHandle(int *p_meta_handle);
META_RESULT  __stdcall META_Init(const META_Error_CallBack  cb);
META_RESULT  __stdcall META_Init_r(const int meta_handle, const META_Error_CallBack  cb);
META_RESULT  __stdcall META_SetSysTraceCallback(const META_SysTrace_CallBack  sys_cb);
META_RESULT  __stdcall META_SetSysTraceCallback_r(const int meta_handle, const META_SysTrace_CallBack  sys_cb);
       void  __stdcall META_Deinit(void);
       void  __stdcall META_Deinit_r(int *p_meta_handle);

// connect with target 
META_RESULT  __stdcall META_ConnectWithTarget(const META_Connect_Req  *req, int *p_bootstop, META_Connect_Report  *p_report);
META_RESULT  __stdcall META_ConnectWithTarget_r(const int meta_handle, const META_Connect_Req  *req, int *p_bootstop, META_Connect_Report  *p_report);
// dsiconnect and shutdown target 
META_RESULT  __stdcall META_DisconnectWithTarget(void);
META_RESULT  __stdcall META_DisconnectWithTarget_r(const int meta_handle);

// connect with target when target already in meta mode 
META_RESULT  __stdcall META_ConnectInMetaMode(const META_ConnectInMETA_Req  *req, int *p_bootstop, META_ConnectInMETA_Report  *p_report);
META_RESULT  __stdcall META_ConnectInMetaMode_r(const int meta_handle, const META_ConnectInMETA_Req  *req, int *p_bootstop, META_ConnectInMETA_Report  *p_report);
// dsiconnect without shutdown target 
META_RESULT  __stdcall META_DisconnectInMetaMode(void);
META_RESULT  __stdcall META_DisconnectInMetaMode_r(const int meta_handle);

// USB-related connect
META_RESULT  __stdcall META_ConnectInMetaModeByUSB(const META_ConnectByUSB_Req  *req, int *p_bootstop, META_ConnectByUSB_Report  *p_report);
META_RESULT  __stdcall META_ConnectInMetaModeByUSB_r(const int meta_handle, const META_ConnectByUSB_Req  *req, int *p_bootstop, META_ConnectByUSB_Report  *p_report);

META_RESULT  __stdcall META_ConnectWithTargetByUSB(const META_ConnectByUSB_Req  *req, int *p_bootstop, META_ConnectByUSB_Report  *p_report);
META_RESULT  __stdcall META_ConnectWithTargetByUSB_r(const int meta_handle, const META_ConnectByUSB_Req  *req, int *p_bootstop, META_ConnectByUSB_Report  *p_report);

META_RESULT  __stdcall META_ConnectWithTargetByUSBEx(const META_ConnectByUSB_Req  *req, int *p_bootstop, META_ConnectByUSB_Report  *p_report, bool close_com_port);
META_RESULT  __stdcall META_ConnectWithTargetByUSBEx_r(const int meta_handle, const META_ConnectByUSB_Req  *req, int *p_bootstop, META_ConnectByUSB_Report  *p_report, bool close_com_port);

META_RESULT  __stdcall META_GetDynamicUSBComPort(unsigned int ms_scan_timeout, unsigned short *com_port, int *p_scanstop);
META_RESULT  __stdcall META_GetDynamicUSBComPort_r(const int meta_handle, unsigned int ms_scan_timeout, unsigned short *com_port, int *p_scanstop);
META_RESULT  __stdcall META_GetDynamicUSBComPortWithPrefix(unsigned int ms_scan_timeout, unsigned short *com_port, int *p_scanstop, const char* prefix);
META_RESULT  __stdcall META_GetDynamicUSBComPortWithPrefix_r(const int meta_handle, unsigned int ms_scan_timeout, unsigned short *com_port, int *p_scanstop, const char* prefix);

// Get target S/W, H/W and Melody version
META_RESULT  __stdcall META_GetTargetVerInfo(const META_GET_VERSION_INFO_CNF  cb, short *token, void *usrData);
META_RESULT  __stdcall META_GetTargetVerInfo_r(const int meta_handle, const META_GET_VERSION_INFO_CNF  cb, short *token, void *usrData);

// Shutdown target 
META_RESULT  __stdcall META_ShutDownTarget(void);
META_RESULT  __stdcall META_ShutDownTarget_r(const int meta_handle);

// ***** Expired Functions -- BEGIN ***** //
// these functions are expired, we encourage you to use META_ConnectWithTarget and META_DisconnectWithTarget 
META_RESULT  __stdcall META_COMM_Set_Baudrate(const META_COMM_BAUDRATE  baudrate);
META_RESULT  __stdcall META_COMM_Set_Baudrate_r(const int meta_handle, const META_COMM_BAUDRATE  baudrate);
META_RESULT  __stdcall META_COMM_Start(const int comm_port, const META_FLOWCTRL  flowctrl);
META_RESULT  __stdcall META_COMM_Start_r(const int meta_handle, const int comm_port, const META_FLOWCTRL  flowctrl);
META_RESULT  __stdcall META_COMM_Stop(void);
META_RESULT  __stdcall META_COMM_Stop_r(const int meta_handle);
META_RESULT  __stdcall META_WaitForTargetReady(unsigned int ms_waiting_time, unsigned int request_count);
META_RESULT  __stdcall META_WaitForTargetReady_r(const int meta_handle, unsigned int ms_waiting_time, unsigned int request_count);
META_RESULT  __stdcall META_GetTargetRequiredMetaVer(unsigned int *p_meta_ver_required_by_target);
META_RESULT  __stdcall META_GetTargetRequiredMetaVer_r(const int meta_handle, unsigned int *p_meta_ver_required_by_target);
// ***** Expired Functions -- END ***** //
#ifdef __META_DLL_WCDMA__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  // end of #ifdef __META_DLL_WCDMA__

//--------------------------------------------------------------------------//
//  RF Testing                                                              //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  RF Testing: data structure definition              //
//-----------------------------------------------------//
typedef short	ARFCN;
typedef short	Gain;
typedef char	BSIC;
typedef short	Power;
typedef unsigned char	TimingAdvance;
typedef char	TSC;
typedef char	TimeSlot;

// RF ID 
#define  RF_ID_UNKNOWN     0x00000000
#define  RF_ID_BRIGHT2     0x00000001
#define  RF_ID_BRIGHT4     0x00000002
#define  RF_ID_AERO        0x00000004
#define  RF_ID_AERO1PLUS   0x00000008
#define  RF_ID_POLARIS1    0x00000010
#define  RF_ID_POLARIS2    0x00000020
#define  RF_ID_SKY74045    0x00000040
#define  RF_ID_BRIGHT5P    0x00000080
#define  RF_ID_MT6116      0x00000100
#define  RF_ID_MT6119      0x00000200
#define  RF_ID_MT6119C     0x00000400
#define  RF_ID_MT6129A     0x00000800
#define  RF_ID_MT6129B     0x00001000
#define  RF_ID_MT6129C     0x00002000
#define  RF_ID_MT6129D     0x00004000
#define  RF_ID_MT6139B     0x00008000
#define  RF_ID_MT6139C     0x00010000
#define  RF_ID_MT6140A     0x00020000
#define  RF_ID_SKY74117    0x00040000
#define  RF_ID_SKY74400    0x00080000
#define  RF_ID_AERO2       0x00100000
#define  RF_ID_MT6140B     0x00200000
#define  RF_ID_ALICEG2S    0x00400000
#define  RF_ID_MT6139E     0x00800000
#define  RF_ID_SKY74137    0x01000000
#define  RF_ID_MT6140C     0x02000000
#define  RF_ID_GRF6201     0x04000000
#define  RF_ID_IRFS3001    0x08000000
#define  RF_ID_MT6140D     0x10000000
#define  RF_ID_AG2550      0x10000001
#define  RF_ID_AERO2E      0x10000002
#define  RF_ID_AD6548      0x10000005     
#define  RF_ID_AD6546      0x10000006
//#define  RF_ID_A60111A     0x10000007
#define  RF_ID_CMOSEDGE    0x10000007
#define  RF_ID_MTKSOC1     0x10000008
#define  RF_ID_MT6255RF    0x10000009
#define  RF_ID_MT6251RF    0x1000000a
#define  RF_ID_MT6252RF    0x1000000c
#define  RF_ID_MT6162      0x1000000d

typedef enum
{
   FrequencyBand400=0,				// GSM 450/480 band
   FrequencyBand850,				// GSM 850 band
   FrequencyBand900,				// GSM 900 band
   FrequencyBand1800,				// DCS 1800 band
   FrequencyBand1900,				// PCS 1900 band

   FrequencyBandCount				// count of supported bands
} FrequencyBand;

typedef struct 
{
	ARFCN			arfcn;				// Absolute radio frequency channel number
	char			sampleNoPerFrame;	// number of samples per frame
	Gain			gain;				// Gain that should be used in power management
	short			frames;				// number of frames
} RfPm_Req;

typedef struct {
	unsigned char	valid;				// if valid != zero, it means the extra info is meaningful. 
										// otherwise, the extra info should be ignore. 
   	int				iOffset;
	int				qOffset;
	int				validSamples;
} RfPmExtraInfo_T;

/**
 * This request structure is used for IR Power scan
 */
typedef struct 
{
    /// original power scan request
    RfPm_Req        m_Pm;
    /// if flag used for specifying the if flag in IR power scan (override the if flag setting)
    char   m_IfFlag;
} RfIrPm_Req;

typedef struct
{
	int				power;				// average power
	int				deviation;			// deviation of power measurement
	Gain			usedGain;			// Gain that is used
	unsigned char	ok;					// status
	RfPmExtraInfo_T	extra_info;			// extra info
} RfPm_Cnf;

typedef struct
{
	ARFCN			arfcn;				// absolute radio frequency channel number
	short			dacValue;			// AFC DAC value
	Gain			gain;				// gain used for AFC testing
	short			testNumber;			// test number
} RfAfc_Req;

typedef struct
{
	short			fcb_ok_number;		// successful number of FCB decoded
	int				freqOffset;			// average frequency error
	int				deviation;			// deviation of frequency error
	unsigned char	ok;					// status
} RfAfc_Cnf;

typedef enum {
	 AB_TX_RANDOM_WITH_SYNC_SEQ
	,NB_TX_ALL_ZEROS_WITHOUT_TSC
	,NB_TX_ALL_ONES_WITHOUT_TSC
	,NB_TX_ALTER_BITS_WITHOUT_TSC
	,NB_TX_RANDOM_WITH_TSC
	,NB_TX_PATTERN_WITHOUT_TSC
	,NB_TX_FIXED_RANDOM_WITH_TSC
	,NB_TX_FIXED_ALL_ZEROS_WITH_TSC
	,NB_TX_FIXED_ALTER_BITS_WITH_TSC
	,NB_TX_FIXED_ALL_ONES_WITH_TSC
    ,NB_TX_FIXED_OE_PATTERN_WITH_TSC
} APCTxPattern;

typedef struct
{
	ARFCN			arfcn;				// Absolute radio frequency channel number
	BSIC			bsic;				// bsic value used in transmission
	Power			power;				// Tx power in the unit of PCL
	short			frames;				// the number of frames NB should transmit
	short			dacValue;			// AFC DAC value
	APCTxPattern	burstTypeNB;
} RfNbtx_Req;

typedef struct
{
	ARFCN			arfcn;				// Absolute radio frequency channel number
	Gain			gain;				// Gain that should be used
	unsigned char	OnOff;				// On or off
} RfCnRx_Req;

typedef enum {
	CONT_TX_ALL_ZEROS
	,CONT_TX_ALL_ONES
	,CONT_TX_ALTERNATE_BITS
	,CONT_TX_PSEUDO_RANDOM
	,CONT_TX_PATTERN_WITHOUT_TSC
} ContTxPattern;

typedef struct
{
	ARFCN			arfcn;				// Absolute radio frequency channel number
	ContTxPattern	pattern;
	unsigned char	OnOff;				// On or off
} RfCnTx_Req;

typedef struct
{
	char	TxTrimI;
	char	TxTrimQ;
	char	TxOffsetI;
	char	TxOffsetQ;
} RfSetBBTXCfg_Req;

typedef struct {
	char	TxTrimI;
	char	TxTrimQ;
	char	TxOffsetI;
	char	TxOffsetQ;
	char	TxCalbias;
	char	TxIQSwap;
	char	TxCMV;
	char	TxGain;
	char	TxCalrcsel;
} RfBBTXCfg2;

typedef struct {
	char	TxTrimI;
	char	TxTrimQ;
	char	TxOffsetI;
	char	TxOffsetQ;
	char	TxCalbias;
	char	TxIQSwap;
	char	TxCMV;
	char	TxGain;
	char	TxCalrcsel;
	char	TxPhasesel;
} RfBBTXCfg3;

typedef struct {
	char    TxTrimI;
	char    TxTrimQ;
	char	TxOffsetI;
	char	TxOffsetQ;
	char	TxCalbias;
	char	TxIQSwap;
	char	TxCMV;
	char	TxGain;
	char	TxCalrcsel;
	char	TxPhasesel;
	char    TxCoarseI;
	char    TxCoarseQ;

}RfBBTXCfg4;  //RfTestCmdSetBBTXCfg4

typedef struct
{
    unsigned char bbtx_common_mode_voltage;
    unsigned char bbtx_gain;
    unsigned char bbtx_calrcsel;
//    unsigned char bbtx_coarseI; // need to set
//   unsigned char bbtx_coarseQ; // need to set
    unsigned char bbtx_trimI;   // need to set
    unsigned char bbtx_trimQ;   // need to set
	unsigned char bbtx_dccoarseI; // need to set
    unsigned char bbtx_dccoarseQ; // need to set
    unsigned char bbtx_offsetI; // need to set
    unsigned char bbtx_offsetQ; // need to set
    unsigned char bbtx_isCalibrated; // need to set
    int           apc_bat_low_voltage;
    int           apc_bat_high_voltage;
    int           apc_bat_low_temperature;
    int           apc_bat_high_temperature;
    unsigned char bbtx_common_mode_voltage_h;
    unsigned char bbtx_gain_h;
    unsigned char bbtx_calrcsel_h;
    unsigned char bbtx_trimI_h;
    unsigned char bbtx_trimQ_h;
//    unsigned char bbtx_coarseI_h;
//    unsigned char bbtx_coarseQ_h;
	unsigned char bbtx_dccoarseI_h;
    unsigned char bbtx_dccoarseQ_h;

    unsigned char bbtx_offsetI_h;
    unsigned char bbtx_offsetQ_h;
    unsigned char bbtx_phsel;
    unsigned char bbtx_phsel_h;
//    unsigned char bbrx_gsm850_gsm900_swap;
 //   unsigned char bbrx_dcs1800_pcs1900_swap;
}BBTXParameters_T;
typedef enum {
    CodingSchemeNone = 0,
	CodingSchemeCS1,
	CodingSchemeCS2,
	CodingSchemeCS3,
	CodingSchemeCS4,
	CodingSchemePRACh8,
	CodingSchemePRACh11,
	CodingSchemeMCS1,
	CodingSchemeMCS2,
	CodingSchemeMCS3,
	CodingSchemeMCS4,
	CodingSchemeMCS5,
	CodingSchemeMCS6,
	CodingSchemeMCS7,
	CodingSchemeMCS8,
	CodingSchemeMCS9
} CodingScheme;

typedef struct {
	ARFCN			arfcn;			// absolute radio frequency channel number
	BSIC			bsic;			// training sequence
	char			timeSlotmask;	// time slot mask, slot_1: 0x01, slot_2: 0x02, slot_3: 0x04, slot_4: 0x08
	Power			powerLev[4];	// power level for each time slot
	CodingScheme	cs[4];			// coding scheme for each time slot
	TimingAdvance	ta;				// time advance
	int				frames;			// the number of frames should transmit
	short			dacValue;		// AFC DAC value
} RfMultiSlotTX_Req;

typedef struct {
	FrequencyBand	rf_band;
	int				power_level;
	int				apc_dac;
} RfSetRampApcLevel_Req;

typedef struct {
	short			dacValue;		// AFC DAC value
} RfSetAfcDacValue_Req;

typedef struct {
	int				cap_id;
} RfSetCrystalCfg_Req;

typedef struct {
	ARFCN			arfcn;			// absolute radio frequency channel number
	BSIC			bsic;			// training sequence
	char			timeSlotmask;	// time slot mask, slot_1: 0x01, slot_2: 0x02, slot_3: 0x04, slot_4: 0x08
	Power			powerLev[4];	// power level for each time slot
	CodingScheme	cs[4];			// coding scheme for each time slot, MCS1~9 is only valid for EPSK function 
	TimingAdvance	ta;				// time advance
	int				frames;			// the number of frames should transmit
	short			dacValue;		// AFC DAC value
	APCTxPattern	pattern;		// Tx pattern is only valid for EPSK function  
	unsigned short	pattern_data;	// if NB_TX_PATTERN_WITHOUT_TSC==pattern, user can input any 16bits value as pattern. 
} Rf_MultiSlotTXEx_Req;

typedef struct {
	unsigned int	id;				// please refer RF_ID_XXXX 
} RFMod_ID;

typedef enum {
	MS_GSM = 0
	,MS_GPRS
	,MS_EGPRS_RX_ONLY
	,MS_EGPRS_FULL_FUNCTION
} MS_CAPABILITY_E;

typedef struct {
	unsigned int	GSM400;			// Zero: not support, Non-zero: support 
	unsigned int	GSM850;
	unsigned int	GSM900;
	unsigned int	DCS1800;
	unsigned int	PCS1900;
} RFBandSupport_S;

typedef struct {
	MS_CAPABILITY_E		capability;
	RFBandSupport_S		band_support;
} RfMsCapability_S;

typedef struct {
	unsigned int	GSM:1;
	unsigned int	GPRS:1;
	unsigned int	EDGE_RX:1;
	unsigned int	EDGE_8PSK_TX:1;
	unsigned int	Calibration_8PM:1;
} RfMsCapabilityBits;

typedef struct {
	unsigned int	GSM400:1;
	unsigned int	GSM850:1;
	unsigned int	GSM900:1;
	unsigned int	DCS1800:1;
	unsigned int	PCS1900:1;
} RfMsBandSupportBits;

typedef struct {
	RfMsCapabilityBits		capability;
	RfMsBandSupportBits		band_support;
} RfMsCapabilityEx_S;


typedef struct {
	unsigned int	GSM:1;
	unsigned int	GPRS:1;
	unsigned int	EDGE_RX:1;
	unsigned int	EDGE_8PSK_TX:1;
	unsigned int	Calibration_8PM:1;
	unsigned int    Calibration_FDT:1;      // new
	unsigned int    Calibration_33Steps:1;  // new
    unsigned int    NSFT:1; // NSFT
    unsigned int    AFCType:1; // AFC Type
    //20100505
    unsigned int    ClosedLoopPowerControl:1;
    unsigned int    OpenLoopPowerControl:1;
    unsigned int    ClosedLoopPowerControlTemperature:1;
} RfMsCapabilityBits_2;

typedef struct {
	RfMsCapabilityBits_2		capability;
	RfMsBandSupportBits		band_support;
} RfMsCapabilityEx2_S;


typedef enum {
	AFC_SINWAVE_OFF = 0
	,AFC_SINWAVE_ON
} AFC_SINWAVE_DETECTION_E;

typedef struct {
	ARFCN			arfcn;				// Absolute radio frequency channel number
	ContTxPattern	pattern;
	unsigned short	pattern_data;
	unsigned char	OnOff;				// On or off 
	unsigned short	modtype;			// modulation type: 0->GMSK, 1->EPSK 
} RfCnTxEx_Req;

typedef struct {
	ARFCN			arfcn;				// Absolute radio frequency channel number
	ContTxPattern	pattern;
	unsigned short	pattern_data;
	unsigned char	OnOff;				// On or off 
	unsigned short	modtype;			// modulation type: 0->GMSK, 1->EPSK 
	Power			powerLev;			// power level 
} RfCnTxEx2_Req;

typedef struct {
	short			dacValue;		// AFC DAC value
} RfGetAfcDacValueAtRTXOffsetCal;

//----------  FDT related structure -----------------------

#define MAX_STEP_CNT   50
typedef struct{
   FrequencyBand	  band;
   ARFCN			  arfcn;
   short		      dac_value[33];
   Gain			      gain;
   short		      repeat_cnt;	// repetitive test counts (frames) for each AFC DAC value
   bool			      capid_cal;	// capid calibration ctrl
   bool			      linear_cal;	// 33 stages calibration ctrl
   //char			      capid_min;	// min value for capid range when capid_cal is True; capid when capid_cal is False
   //char			      capid_max;	// max value for capid range
   int			      capid_min;	// min value for capid range when capid_cal is True; capid when capid_cal is False
   int			      capid_max;	// max value for capid range

}Rf_DSSAFC_T;

typedef struct
{
   FrequencyBand 	   band;
   ARFCN			   arfcn;
   Gain				   gain[6];		// gain for rx slot 0/1/2/3/4/5
   short			   repeat_cnt;	// repetitive test counts (frames) for each ARFCN value
//   short			   dac_value;	// Use InitDacValue from AFC calibration when dacValue = 0 (or -1)
} Rf_DSSPL_T;

typedef struct
{
   bool				   afc_cal;
   bool                pl_cal;       // Control whether Path loss calibration is needed or not
   char				   sync_sb_num;	// the SB frame numbers needed for sync process before path loss calibration
   short		       power;               // the power level expected to measure from test set
   Rf_DSSAFC_T 	       AfcDSS;
   char				   step_cnt;
   Rf_DSSPL_T	       PathLossDSS[MAX_STEP_CNT-2]; // because sync process will need 2 steps

}Rf_DTS_REQ_T;

typedef struct
{
   FrequencyBand	    band;
   ARFCN			    arfcn;
   char				    timeslot_per_frame;	
   char				    apc_dac_pcl_sel;				// 1: apc_dac, 0: apc_pcl
   short			    apc_dac_pcl_value[4];
   //unsigned char		pa_vbias_val;	
   unsigned char        pa_vbias_val[4];
   unsigned char        is_low_pcl[4];

   CodingScheme		    cs[4];
   int			        repeat_cnt;			
   short			    afc_dac_value;
   char				    tsc;
   APCTxPattern			pattern;		
   unsigned short		pattern_data;
} Rf_USSAPC_T;

typedef struct
{
//   bool                pa_vbias_cal;
   char				   step_cnt;
   short               high_apc_dcoffset[FrequencyBandCount];
   //int                 lowest_power[FrequencyBandCount];  // FrequencyBandCount
   Rf_USSAPC_T	       ApcUSS[MAX_STEP_CNT];
}Rf_UTS_REQ_T;

typedef struct
{
   int	    power[MAX_STEP_CNT-2];  // because sync process will need 2 steps
   short    valid_sample[MAX_STEP_CNT-2];
   bool		ok;
} Rf_DSSPL_RESULT_T;

typedef struct
{
   int	    freq_offset[33];	// only valid when 33 stage calibration is ON
   int	    deviation[33];		// only valid when 33 stage calibration is ON
   short	fcb_ok_number[33];  // only valid when 33 stage calibration is ON
   //char		capid;			    // only valid when capid calibration is ON
   int		capid;			    // only valid when capid calibration is ON
   short	init_dac_value; 	// only valid when 33 stage calibration is OFF
   int	    slope;              // only valid when 33 stage calibration is OFF
   bool		ok;
} Rf_DSSAFC_RESULT_T;

#define FHC_PRE_CAPID_SEARCH_NUM   9
#define FHC_MAX_CAPID_SEARCH_NUM   (7 + FHC_PRE_CAPID_SEARCH_NUM)
typedef struct
{
   int               path_loss_cnt;
   int               freq_offset;
   int               capid_freq_offset_min;
   int               capid_freq_offset[FHC_MAX_CAPID_SEARCH_NUM];		// 20 is the possible max value for FHC_MAX_CAPID_SEARCH_NUM in target side
   int               capid_search_order[FHC_MAX_CAPID_SEARCH_NUM];	// 20 is the possible max value for FHC_MAX_CAPID_SEARCH_NUM in target side
   int               capid;
   int               capid_high;
   int               capid_low;   
   int               capid_best;
   short             afc_dac;
   short             arfcn;
   short             capid_cnt;
   short             repeat_index;
   char              state;
   char              capid_index;
   char              capid_okay_cnt;
   char              afc_dac_index;
   char              sb_okay_cnt;
   unsigned char     sb_fail_cnt;
   unsigned char     fb_fail_cnt;
   bool              pl_started;
   bool              pre_capid_cal_ok[FHC_PRE_CAPID_SEARCH_NUM];

}Rf_FHC_DTSM_INFO_T;

typedef enum  {
	DTS_RESULT_READY = 0,		// DTS results is ready to get back
	DTS_RESULT_NOT_READY,		// DTS result is still in progress and not ready to get back
	DTS_RESULT_NOT_REQUESTED	// Haven't called the META_Rf_StartFdtDL() in advance.
}RF_DTS_GET_RESULT_STATUS;
typedef struct
{
   RF_DTS_GET_RESULT_STATUS		status;
   Rf_DSSPL_RESULT_T	  PLResult;
   Rf_DSSAFC_RESULT_T	  AfcResult;
   Rf_FHC_DTSM_INFO_T     DtsmInfo;
	
} Rf_DTS_CNF_T;

META_RESULT  __stdcall META_Rf_GetFdtDL(unsigned int ms_timeout, Rf_DTS_CNF_T *fdt_dl_get_result_cnf);
META_RESULT  __stdcall META_Rf_GetFdtDL_r(const int meta_handle, unsigned int ms_timeout, Rf_DTS_CNF_T *fdt_dl_get_result_cnf);
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult(unsigned int ms_timeout, const Rf_DTS_REQ_T  *fdt_dl_req);
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_r(const int meta_handle, unsigned int ms_timeout, const Rf_DTS_REQ_T  *fdt_dl_req);

//-----------------------------------------------------//
//  TX Ramping Table                                   //
//-----------------------------------------------------//
#define PROFILE_NUM             16
#define ARFCN_SECTION_NUM       12
#define ARFCN_SECTION_NUM_Ex       64
typedef  struct
{
   unsigned char   point[2][16];	// ramp up/down profile

} sRAMPAREADATA;

typedef  struct
{
   short			max_arfcn;		// sub-band boundary of this PCL weighting area
   unsigned short   mid_level;		// PCLboundary level to apply high/low weighting
   unsigned short   hi_weight;		// scale factor of PCLs higher than mid_level
   unsigned short   low_weight;		// scale factor of PCLs lower than mid_level

} sARFCN_SECTION;

typedef  struct
{
   int				lowest_power;						// The lower apc power of the indicated band
   unsigned short	power[16];							// The mapping of power level to apc dac value
   sRAMPAREADATA	ramp[ PROFILE_NUM ];				// ramp profile
   sARFCN_SECTION	arfcn_weight[ ARFCN_SECTION_NUM ];	// profile of weighting power level by PCL and sub-band
   unsigned short	battery_compensate[3][3];			// [volt][temp] 
   short			tx_afc_offset;
} sRAMPDATA;

typedef struct
{
   int				lowest_power;						// The lower apc power of the indicated band
   unsigned short	power[16];							// The mapping of power level to apc dac value
   sRAMPAREADATA	ramp[ PROFILE_NUM ];				// ramp profile
   sARFCN_SECTION	arfcn_weight[ ARFCN_SECTION_NUM_Ex ];	// profile of weighting power level by PCL and sub-band
   unsigned short	battery_compensate[3][3];			// [volt][temp] 
   short			tx_afc_offset;
} sRAMPDATA_Ex;

typedef  struct
{
   int				lowest_power;						// The lower apc power of the indicated band
   unsigned short	power[16];							// The mapping of power level to apc dac value
   sRAMPAREADATA	ramp[ PROFILE_NUM ];				// ramp profile
   sARFCN_SECTION	arfcn_weight[ ARFCN_SECTION_NUM ];	// profile of weighting power level by PCL and sub-band
   unsigned short	battery_compensate[3][3];			// [volt][temp] 
   short			tx_afc_offset;
   unsigned char	vbias[16];
} sRAMPDATA_Ex2;

typedef struct
{
   sRAMPDATA          rampData;							// apc ramp profile of all bands
}l1cal_rampTable_T;

// useless: Ex and Ex2
typedef struct
{
   sRAMPDATA_Ex          rampData;							// apc ramp profile of all bands
}l1cal_rampTable_T_Ex;

typedef struct
{
   sRAMPDATA_Ex2          rampData;							// apc ramp profile of all bands
}l1cal_rampTable_T_Ex2;


//-----------------------------------------------------//
//  TX Inter Ramping Table                             //
//-----------------------------------------------------//

// interRampData 
typedef struct {   
	unsigned char	interRampData[16];
} l1cal_interRampData_T;

// EPSK interRampData 
typedef struct {
	unsigned char	EPSK_interRampData[4][16];
} l1cal_EPSK_interRampData_T;

#ifdef __META_DLL_WCDMA__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif //#ifdef __META_DLL_WCDMA__


//-----------------------------------------------------//
//  RF Module Special Coef                             //
//-----------------------------------------------------//

//mt6140D
typedef struct{
   short		pcl_index;
   unsigned char pa_vbias1;   
}pa_vbias;

typedef struct {
   pa_vbias GSM850_pa_vbias[8];
   pa_vbias GSM900_pa_vbias[8];   
   pa_vbias DCS1800_pa_vbias[8];
   pa_vbias PCS1900_pa_vbias[8];
   //pa_vbias low_band_pa_vbias[8];
   //pa_vbias high_band_pa_vbias[8];
}mt6140tx_pa_vbias;

typedef struct{  
      mt6140tx_pa_vbias data;
}mt6140tx;  
// Skyworks 
typedef struct {
	unsigned int		icorrection;
	unsigned int		qcorrection;
} RF_SKY74045_IP2_Coef;

typedef struct {
	RF_SKY74045_IP2_Coef	coef[5/*band*/];
} RF_SKY74045_RX_Coef;

typedef struct {
	RF_SKY74045_RX_Coef		rx;
} RF_SKY74045_Coef_T;

typedef struct {
	unsigned int			ipol;
	unsigned int			qpol;
} RF_SKY74117_IP2_Pol;

typedef struct {
	RF_SKY74045_IP2_Coef	coef[5/*band*/];
	RF_SKY74117_IP2_Pol		pol[5/*band*/];
} RF_SKY74117_RX_Coef;

typedef struct {
	RF_SKY74117_RX_Coef		rx;
} RF_SKY74117_Coef_T;

// MT6139B 
typedef struct {
	unsigned int		acode;
	unsigned int		amcode;
} RF_MT6139B_IP2_Coef;

typedef struct {  
	RF_MT6139B_IP2_Coef		coef[5/*band*/];
	unsigned int			rxamcalmode;
} RF_MT6139B_RX_Coef;

typedef struct {
	RF_MT6139B_RX_Coef		rx;
} RF_MT6139B_Coef_T;

// Bright5P 
typedef struct {
	unsigned int		word6_4_0;
	unsigned int		word6_5_0;
	unsigned int		word6_6_0;
	unsigned int		word6_7_0;
	unsigned int		bvmode;
	unsigned int		c3mode;
	unsigned int		wordC3;
} RF_BRIGHT5P_TX_Coef;

typedef struct {
	RF_BRIGHT5P_TX_Coef		tx;
} RF_BRIGHT5P_Coef_T;

typedef struct
{
   unsigned char REFDET_SLOPE_SKEW ;
   unsigned char AM_FB_DAC; 
}ad6546txcoef;

typedef struct
{
   char MID_GAMA_THRESHOLD;
   char LOW_GAMA_THRESHOLD;
   char MID_DELTA_SLOPE_SKEW;
   char LOW_DELTA_SLOPE_SKEW;
   char MID_DELTA_APC_CAP;
   char LOW_DELTA_APC_CAP;
} ad6546tx_reg8_highband_delta;

typedef struct
{
    unsigned long Address           : 7;
    unsigned long POLAR_APC_CAP     : 5;
    unsigned long VGA_SLOPE         : 4;
    unsigned long REFDET_SLOPE_SKEW : 4;
    unsigned long AM_FB_DAC         : 4;
    unsigned long reserved          : 8;
} AM_LOOP;
// 20090920 YH: add for support reg8 setting
typedef union  // for AD6546 REG8
{
    AM_LOOP AMLoop;
    unsigned long RegData;
} ad6546tx_reg8;

typedef  struct
{ 
    ad6546txcoef   CalData[4];
    ad6546tx_reg8  Reg8_default[4];
} ad6546tx;

typedef struct
{
	//int rf_band;
	short afc_offset[FrequencyBandCount];

}RF_SET_AFC_DAC_OFFSET_REQ_T;

typedef struct
{
    short afc_offset[FrequencyBandCount];

}RF_GET_AFC_DAC_OFFSET_CNF_T;


//-----------------------------------------------------//
//  RF Testing: callback function definition           //
//-----------------------------------------------------//
typedef void (__stdcall *META_RF_PM_CNF)(const RfPm_Cnf *cnf, const short token, void *usrData);
typedef void (__stdcall *META_RF_AFC_CNF)(const RfAfc_Cnf *cnf, const short token, void *usrData);
typedef void (__stdcall *META_RF_NB_TX_CNF)(const unsigned char cnf, const short token, void *usrData);
typedef void (__stdcall *META_RF_CONT_RX_CNF)(const unsigned char cnf, const short token, void *usrData);
typedef void (__stdcall *META_RF_CONT_TX_CNF)(const unsigned char cnf, const short token, void *usrData);
typedef void (__stdcall *META_RF_SETBBTX_CFG_CNF)(const unsigned char cnf, const short token, void *usrData);
typedef void (__stdcall *META_RF_SELBAND_CNF)(const unsigned char cnf, const short token, void *usrData);
typedef void (__stdcall *META_RF_STOP_CNF)(const unsigned char cnf, const short token, void *usrData);
typedef void (__stdcall *META_RF_MULTISLOT_TX_CNF)(const unsigned char cnf, const short token, void *usrData);
typedef void (__stdcall *META_RF_SET_RAMPAPCLEVEL_CNF)(const unsigned char cnf, const short token, void *usrData);
typedef void (__stdcall *META_RF_SET_AFCDACVALUE_CNF)(const unsigned char cnf, const short token, void *usrData);

//-----------------------------------------------------//
//  RF Testing: exported function definition           //
//-----------------------------------------------------//
META_RESULT  __stdcall META_Rf_PM(const RfPm_Req *req, const META_RF_PM_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_PM_r(const int meta_handle, const RfPm_Req *req, const META_RF_PM_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_PmEx(unsigned int ms_timeout, const RfPm_Req *req, RfPm_Cnf *cnf);
META_RESULT  __stdcall META_Rf_PmEx_r(const int meta_handle, unsigned int ms_timeout, const RfPm_Req *req, RfPm_Cnf *cnf);
META_RESULT  __stdcall META_Rf_IrPm(unsigned int ms_timeout, const RfIrPm_Req *req, RfPm_Cnf *cnf);
META_RESULT  __stdcall META_Rf_IrPm_r(const int meta_handle, unsigned int ms_timeout, const RfIrPm_Req *req, RfPm_Cnf *cnf);

META_RESULT  __stdcall META_Rf_AFC(const RfAfc_Req *req, const META_RF_AFC_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_AFC_r(const int meta_handle, const RfAfc_Req *req, const META_RF_AFC_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_NB_TX(const RfNbtx_Req *req, const META_RF_NB_TX_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_NB_TX_r(const int meta_handle, const RfNbtx_Req *req, const META_RF_NB_TX_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_CONTINUE_RX(const RfCnRx_Req *req, const META_RF_CONT_RX_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_CONTINUE_RX_r(const int meta_handle, const RfCnRx_Req *req, const META_RF_CONT_RX_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_CONTINUE_TX(const RfCnTx_Req *req, const META_RF_CONT_TX_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_CONTINUE_TX_r(const int meta_handle, const RfCnTx_Req *req, const META_RF_CONT_TX_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_SetBBTXCfg(const RfSetBBTXCfg_Req *req, const META_RF_SETBBTX_CFG_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_SetBBTXCfg_r(const int meta_handle, const RfSetBBTXCfg_Req *req, const META_RF_SETBBTX_CFG_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_SelectFrequencyBand1900(const unsigned char selectPCS1900, const META_RF_SELBAND_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_SelectFrequencyBand1900_r(const int meta_handle, const unsigned char selectPCS1900, const META_RF_SELBAND_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_Stop(const META_RF_STOP_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_Stop_r(const int meta_handle, const META_RF_STOP_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_MultiSlot_TX(const RfMultiSlotTX_Req *req, const META_RF_MULTISLOT_TX_CNF  cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_MultiSlot_TX_r(const int meta_handle, const RfMultiSlotTX_Req *req, const META_RF_MULTISLOT_TX_CNF  cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_SetAfcDacValue(const RfSetAfcDacValue_Req *req, const META_RF_SET_AFCDACVALUE_CNF  cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_SetAfcDacValue_r(const int meta_handle, const RfSetAfcDacValue_Req *req, const META_RF_SET_AFCDACVALUE_CNF  cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_SetBBTxCfg2(unsigned int ms_timeout, const RfBBTXCfg2  *tx_cfg_req, RfBBTXCfg2  *tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_SetBBTxCfg2_r(const int meta_handle, unsigned int ms_timeout, const RfBBTXCfg2  *tx_cfg_req, RfBBTXCfg2  *tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_GetBBTxCfg2(unsigned int ms_timeout, RfBBTXCfg2  *tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_GetBBTxCfg2_r(const int meta_handle, unsigned int ms_timeout, RfBBTXCfg2  *tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_SetCrystalCapId(unsigned int ms_timeout, const RfSetCrystalCfg_Req  *req);
META_RESULT  __stdcall META_Rf_SetCrystalCapId_r(const int meta_handle, unsigned int ms_timeout, const RfSetCrystalCfg_Req  *req);
META_RESULT  __stdcall META_Rf_BBTXAutoCal(unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_BBTXAutoCal_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_QueryMSCapability(unsigned int ms_timeout, RfMsCapability_S  *p_type);
META_RESULT  __stdcall META_Rf_QueryMSCapability_r(const int meta_handle, unsigned int ms_timeout, RfMsCapability_S  *p_type);
META_RESULT  __stdcall META_Rf_QueryMSCapabilityEx(unsigned int ms_timeout, RfMsCapabilityEx_S  *p_ms_cap);
META_RESULT  __stdcall META_Rf_QueryMSCapabilityEx_r(const int meta_handle, unsigned int ms_timeout, RfMsCapabilityEx_S  *p_ms_cap);
META_RESULT  __stdcall META_Rf_SetAfcSinWaveDetection(unsigned int ms_timeout, AFC_SINWAVE_DETECTION_E  bIsAfcSinWaveOn);
META_RESULT  __stdcall META_Rf_SetAfcSinWaveDetection_r(const int meta_handle, unsigned int ms_timeout, AFC_SINWAVE_DETECTION_E  bIsAfcSinWaveOn);
META_RESULT  __stdcall META_Rf_QueryIfTwoApcDCOffsetSupport(unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_QueryIfTwoApcDCOffsetSupport_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_MultiSlot_TX_Ex(unsigned int ms_timeout, const Rf_MultiSlotTXEx_Req *req);
META_RESULT  __stdcall META_Rf_MultiSlot_TX_Ex_r(const int meta_handle, unsigned int ms_timeout, const Rf_MultiSlotTXEx_Req *req);
META_RESULT  __stdcall META_Rf_GetRFID(unsigned int ms_timeout, RFMod_ID *cnf);
META_RESULT  __stdcall META_Rf_GetRFID_r(const int meta_handle, unsigned int ms_timeout, RFMod_ID *cnf);
META_RESULT  __stdcall META_Rf_CONTINUE_TX_Ex(unsigned int ms_timeout, const RfCnTxEx_Req *req);
META_RESULT  __stdcall META_Rf_CONTINUE_TX_Ex_r(const int meta_handle, unsigned int ms_timeout, const RfCnTxEx_Req *req);
META_RESULT  __stdcall META_Rf_SetBBTxCfg3(unsigned int ms_timeout, const RfBBTXCfg3  *tx_cfg_req, RfBBTXCfg3  *tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_SetBBTxCfg3_r(const int meta_handle, unsigned int ms_timeout, const RfBBTXCfg3  *tx_cfg_req, RfBBTXCfg3  *tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_GetBBTxCfg3(unsigned int ms_timeout, RfBBTXCfg3  *tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_GetBBTxCfg3_r(const int meta_handle, unsigned int ms_timeout, RfBBTXCfg3  *tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_CONTINUE_TX_Ex2(unsigned int ms_timeout, const RfCnTxEx2_Req *req);
META_RESULT  __stdcall META_Rf_CONTINUE_TX_Ex2_r(const int meta_handle, unsigned int ms_timeout, const RfCnTxEx2_Req *req);
META_RESULT  __stdcall META_Rf_GetAfcDacValueAtRTXOffsetCal(unsigned int ms_timeout, RfGetAfcDacValueAtRTXOffsetCal *cnf);
META_RESULT  __stdcall META_Rf_GetAfcDacValueAtRTXOffsetCal_r(const int meta_handle, unsigned int ms_timeout, RfGetAfcDacValueAtRTXOffsetCal *cnf);

META_RESULT  __stdcall META_Rf_SetBBTxCfg4(unsigned int ms_timeout, const RfBBTXCfg4  *tx_cfg_req, RfBBTXCfg4  *tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_SetBBTxCfg4_r(const int meta_handle, unsigned int ms_timeout, const RfBBTXCfg4  *tx_cfg_req, RfBBTXCfg4  *tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_GetBBTxCfg4(unsigned int ms_timeout, RfBBTXCfg4  *tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_GetBBTxCfg4_r(const int meta_handle, unsigned int ms_timeout, RfBBTXCfg4  *tx_cfg_cnf);


META_RESULT  __stdcall META_Rf_SetBBTxCfg5(unsigned int ms_timeout, const RfBBTXCfg4  *tx_cfg_req, RfBBTXCfg4  *tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_SetBBTxCfg5_r(const int meta_handle, unsigned int ms_timeout, const RfBBTXCfg4  *tx_cfg_req, RfBBTXCfg4  *tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_GetBBTxCfg5(unsigned int ms_timeout, RfBBTXCfg4  *tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_GetBBTxCfg5_r(const int meta_handle, unsigned int ms_timeout, RfBBTXCfg4  *tx_cfg_cnf);


META_RESULT  __stdcall META_Rf_SetBBTxCfg6(unsigned int ms_timeout, const RfBBTXCfg4  *tx_cfg_req, RfBBTXCfg4  *tx_cfg_cnf); 
META_RESULT  __stdcall META_Rf_SetBBTxCfg6_r(const int meta_handle, unsigned int ms_timeout, const RfBBTXCfg4  *tx_cfg_req, RfBBTXCfg4  *tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_GetBBTxCfg6(unsigned int ms_timeout, RfBBTXCfg4  *tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_GetBBTxCfg6_r(const int meta_handle, unsigned int ms_timeout, RfBBTXCfg4  *tx_cfg_cnf);



//-----------------------------------------------------//
//  RunTime Setting Functions Without Update NVRAM     //
//-----------------------------------------------------//
META_RESULT  __stdcall META_Rf_SetRampTable(unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T  *ramp);
META_RESULT  __stdcall META_Rf_SetRampTable_r(const int meta_handle, unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T  *ramp);
META_RESULT  __stdcall META_Rf_SetRampApcLevel(const RfSetRampApcLevel_Req *req, const META_RF_SET_RAMPAPCLEVEL_CNF  cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_SetRampApcLevel_r(const int meta_handle, const RfSetRampApcLevel_Req *req, const META_RF_SET_RAMPAPCLEVEL_CNF  cb, short *token, void *usrData);
META_RESULT  __stdcall META_Rf_EPSK_SetRampTable(unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T  *ramp);
META_RESULT  __stdcall META_Rf_EPSK_SetRampTable_r(const int meta_handle, unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T  *ramp);
META_RESULT  __stdcall META_Rf_EPSK_SetRampTable_Ex(unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex  *ramp);
META_RESULT  __stdcall META_Rf_EPSK_SetRampTable_Ex_r(const int meta_handle, unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex  *ramp);
META_RESULT  __stdcall META_Rf_EPSK_SetRampTable_Ex2(unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex2  *ramp);
META_RESULT  __stdcall META_Rf_EPSK_SetRampTable_Ex2_r(const int meta_handle, unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex2  *ramp);


META_RESULT  __stdcall META_Rf_EPSK_SetRampApcLevel(unsigned int ms_timeout, const RfSetRampApcLevel_Req *req);
META_RESULT  __stdcall META_Rf_EPSK_SetRampApcLevel_r(const int meta_handle, unsigned int ms_timeout, const RfSetRampApcLevel_Req *req);
META_RESULT  __stdcall META_Rf_SetRFImmediateBSI(unsigned int ms_timeout, const unsigned int bsi_data);
META_RESULT  __stdcall META_Rf_SetRFImmediateBSI_r(const int meta_handle, unsigned int ms_timeout, const unsigned int bsi_data);
META_RESULT  __stdcall META_Rf_GetRFImmediateBSI(unsigned int ms_timeout, unsigned int bsi_addr, unsigned int *p_bsi_data);
META_RESULT  __stdcall META_Rf_GetRFImmediateBSI_r(const int meta_handle, unsigned int ms_timeout, unsigned int bsi_addr, unsigned int *p_bsi_data);

META_RESULT  __stdcall META_Rf_SetRampTable_Ex(unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex  *ramp);
META_RESULT  __stdcall META_Rf_SetRampTable_Ex_r(const int meta_handle, unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex  *ramp);
META_RESULT  __stdcall META_Rf_SetRampTable_Ex2(unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex2  *ramp);
META_RESULT  __stdcall META_Rf_SetRampTable_Ex2_r(const int meta_handle, unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex2  *ramp);
// Skyworks 
META_RESULT  __stdcall META_Rf_SKY74045_SetSpecialCoef(unsigned int ms_timeout, const RF_SKY74045_Coef_T *rf_mod_coef);
META_RESULT  __stdcall META_Rf_SKY74045_SetSpecialCoef_r(const int meta_handle, unsigned int ms_timeout, const RF_SKY74045_Coef_T *rf_mod_coef);
META_RESULT  __stdcall META_Rf_SKY74117_SetSpecialCoef(unsigned int ms_timeout, const RF_SKY74117_Coef_T *rf_mod_coef);
META_RESULT  __stdcall META_Rf_SKY74117_SetSpecialCoef_r(const int meta_handle, unsigned int ms_timeout, const RF_SKY74117_Coef_T *rf_mod_coef);
// MT6139B 
META_RESULT  __stdcall META_Rf_MT6139B_SetSpecialCoef(unsigned int ms_timeout, const RF_MT6139B_Coef_T *rf_mod_coef);
META_RESULT  __stdcall META_Rf_MT6139B_SetSpecialCoef_r(const int meta_handle, unsigned int ms_timeout, const RF_MT6139B_Coef_T *rf_mod_coef);
// Renesas Bright5P 
META_RESULT  __stdcall META_Rf_BRIGHT5P_SetSpecialCoef(unsigned int ms_timeout, const RF_BRIGHT5P_Coef_T *rf_mod_coef);
META_RESULT  __stdcall META_Rf_BRIGHT5P_SetSpecialCoef_r(const int meta_handle, unsigned int ms_timeout, const RF_BRIGHT5P_Coef_T *rf_mod_coef);

//---------------------------------------------------------------------------------------------------
META_RESULT  __stdcall META_Rf_32kCalibration(unsigned int ms_timeout, int *p_result);
META_RESULT  __stdcall META_Rf_32kCalibration_r(const int meta_handle, unsigned int ms_timeout, int *p_result);

META_RESULT  __stdcall META_Rf_AD6546_SetSpecialCoef(unsigned int ms_timeout, const ad6546tx *rf_mod_coef, const char *buf, const int buf_len);
META_RESULT  __stdcall META_Rf_AD6546_SetSpecialCoef_r(const int meta_handle, unsigned int ms_timeout, const ad6546tx *rf_mod_coef, const char *buf, const int buf_len);

META_RESULT  __stdcall META_Rf_StartFdtDL(unsigned int ms_timeout, const Rf_DTS_REQ_T  *fdt_dl_req,  Rf_DTS_CNF_T *fdt_dl_cnf);
META_RESULT  __stdcall META_Rf_StartFdtDL_r(const int meta_handle, unsigned int ms_timeout, const Rf_DTS_REQ_T  *fdt_dl_req,  Rf_DTS_CNF_T *fdt_dl_cnf); 

META_RESULT  __stdcall META_Rf_StartFdtUL(unsigned int ms_timeout, const Rf_UTS_REQ_T  *fdt_ul_req);
META_RESULT  __stdcall META_Rf_StartFdtUL_r(const int meta_handle, unsigned int ms_timeout, const Rf_UTS_REQ_T  *fdt_ul_req);


META_RESULT  __stdcall META_Rf_QueryMSCapabilityEx2(unsigned int ms_timeout, RfMsCapabilityEx2_S  *p_ms_cap);
META_RESULT  __stdcall META_Rf_QueryMSCapabilityEx2_r(const int meta_handle, unsigned int ms_timeout, RfMsCapabilityEx2_S  *p_ms_cap);




META_RESULT  __stdcall META_Rf_GetAFCDacTRxOffset(unsigned int ms_timeout, //const int rf_band_req, 
												  RF_GET_AFC_DAC_OFFSET_CNF_T *cnf);
												  //short *p_afc_offset_cnf);

META_RESULT  __stdcall META_Rf_GetAFCDacTRxOffset_r(const int meta_handle, 
													unsigned int ms_timeout, 
													//const int rf_band_req,
													RF_GET_AFC_DAC_OFFSET_CNF_T *cnf);
													//short *p_afc_offset_cnf);




META_RESULT  __stdcall META_Rf_SetAFCDacTRxOffset(unsigned int ms_timeout, const RF_SET_AFC_DAC_OFFSET_REQ_T *req);
META_RESULT  __stdcall META_Rf_SetAFCDacTRxOffset_r(const int meta_handle, 
													unsigned int ms_timeout, 
													const RF_SET_AFC_DAC_OFFSET_REQ_T *req);


//--------------------------------------------------------------------------//
//  BER NSFT (Bit Error Rate in Non-signaling Final Test) : not release     //
//--------------------------------------------------------------------------//
typedef struct{
	FrequencyBand 	band;
	ARFCN			BCH_ARFCN;
	ARFCN			TCH_ARFCN;
	Gain			BCH_gain;
	Gain			TCH_gain;
	TSC				tsc;
	TimeSlot		TCH_slot;
	Power			tx_power_level;
	bool			is_EPSK_tx;
    CodingScheme	epsk_cs;
}Rf_NSFT_REQ_T;

typedef struct{
	Power tx_power_level;
}Rf_NSFT_TX_POWERE_REQ_T;

typedef struct{
	Power			tx_power_level;
	CodingScheme	epsk_cs;
	TimeSlot		TCH_slot;
}Rf_NSFT_EPSK_MOD_CHANGE_REQ_T;

// Start the BER NSFT process
META_RESULT  __stdcall META_Rf_NSFT_Start(unsigned int ms_timeout, const  Rf_NSFT_REQ_T *req);
META_RESULT  __stdcall META_Rf_NSFT_Start_r(const int meta_handle, unsigned int ms_timeout, const  Rf_NSFT_REQ_T *req);
// In NSFT process, change the frequency channel
META_RESULT  __stdcall META_Rf_NSFT_ChangeSettings(unsigned int ms_timeout, const  Rf_NSFT_REQ_T *req);
META_RESULT  __stdcall META_Rf_NSFT_ChangeSettings_r(const int meta_handle, unsigned int ms_timeout, const  Rf_NSFT_REQ_T *req);
// Stop the BER NSFT porcess
META_RESULT  __stdcall META_Rf_NSFT_Stop(unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_NSFT_Stop_r(const int meta_handle, unsigned int ms_timeout);
// In NSFT TX performance test, change different tx power.
META_RESULT  __stdcall META_Rf_NSFT_ChangePower(unsigned int ms_timeout, const Rf_NSFT_TX_POWERE_REQ_T *req);
META_RESULT  __stdcall META_Rf_NSFT_ChangePower_r(const int meta_handle, unsigned int ms_timeout, const Rf_NSFT_TX_POWERE_REQ_T *req);
// In NSFT TX performance test, change to EPSK mode and set tx power.
META_RESULT  __stdcall META_Rf_NSFT_ChangeToEPSK(unsigned int ms_timeout, const Rf_NSFT_EPSK_MOD_CHANGE_REQ_T *req);
META_RESULT  __stdcall META_Rf_NSFT_ChangeToEPSK_r(const int meta_handle, unsigned int ms_timeout, const Rf_NSFT_EPSK_MOD_CHANGE_REQ_T *req);

// query OE PATTERN ready (NO OP function, just for query)
META_RESULT  __stdcall META_Rf_OE_Pattern_Ready();
META_RESULT  __stdcall META_Rf_AFC_Type_Query_Ready();


META_RESULT  __stdcall META_Rf_PowerOn(unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_PowerOn_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_PowerOff(unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_PowerOff_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_QueryPowerState(unsigned int ms_timeout, char *pRfPwrState);
META_RESULT  __stdcall META_Rf_QueryPowerState_r(const int meta_handle, unsigned int ms_timeout,  char *pRfPwrState);

typedef struct
{
    char rollback_2t;
    char rollback_3t;
    char rollback_4t;
    char rollback_5t;
}sTX_POWERROLLBACK;

typedef struct
{
	int band;
    sTX_POWERROLLBACK PowerRollbackTable;
}Rf_TX_ROLLBACK_REQ_T;

typedef struct
{
    sTX_POWERROLLBACK   rollback_data[FrequencyBandCount];
}l1cal_tx_power_rollback_T;

META_RESULT  __stdcall META_Rf_SetTXPowerRollbackGMSK(unsigned int ms_timeout, Rf_TX_ROLLBACK_REQ_T *req);
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackGMSK_r(const int meta_handle, unsigned int ms_timeout,  Rf_TX_ROLLBACK_REQ_T *req);
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackEPSK(unsigned int ms_timeout, Rf_TX_ROLLBACK_REQ_T *req);
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackEPSK_r(const int meta_handle, unsigned int ms_timeout,  Rf_TX_ROLLBACK_REQ_T *req);
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackTableGMSK(unsigned int ms_timeout, const l1cal_tx_power_rollback_T  *table);
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackTableGMSK_r(const int meta_handle, unsigned int ms_timeout, const l1cal_tx_power_rollback_T  *table);
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackTableEPSK(unsigned int ms_timeout, const l1cal_tx_power_rollback_T  *table);
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackTableEPSK_r(const int meta_handle, unsigned int ms_timeout, const l1cal_tx_power_rollback_T  *table);

typedef struct
{
   unsigned short data[16];
} sTXPC_ADCDATA;

typedef struct
{
   unsigned short data[8];
} sTXPC_TEMPDATA;

typedef struct
{
   char           is_calibrated;
   sTXPC_ADCDATA  adc[FrequencyBandCount];
   short          temperature;
   sTXPC_TEMPDATA temp[FrequencyBandCount];
} sTXPC_L1CAL;

typedef sTXPC_L1CAL l1cal_txpc_T;

typedef struct
{
    unsigned char  band;
    short pcl;
}Rf_GET_TXPC_PD_REQ_T;


META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueByPCLGMSK(unsigned int ms_timeout, const Rf_GET_TXPC_PD_REQ_T* req, unsigned short * PDValue);
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueByPCLGMSK_r(const int meta_handle, unsigned int ms_timeout, const Rf_GET_TXPC_PD_REQ_T* req, unsigned short * PDValue);
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueByPCLEPSK(unsigned int ms_timeout, const Rf_GET_TXPC_PD_REQ_T* req, unsigned short * PDValue);
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueByPCLEPSK_r(const int meta_handle, unsigned int ms_timeout, const Rf_GET_TXPC_PD_REQ_T* req, unsigned short * PDValue);
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueGMSK(unsigned int ms_timeout, l1cal_txpc_T *table);
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueGMSK_r(const int meta_handle, unsigned int ms_timeout, l1cal_txpc_T *table);
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueEPSK(unsigned int ms_timeout, l1cal_txpc_T *table);
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueEPSK_r(const int meta_handle, unsigned int ms_timeout, l1cal_txpc_T *table);
META_RESULT  __stdcall META_Rf_GetTXPCSubbandCompensationGMSK(unsigned int ms_timeout, const unsigned char band, l1cal_rampTable_T  *ramp);
META_RESULT  __stdcall META_Rf_GetTXPCSubbandCompensationGMSK_r(const int meta_handle, unsigned int ms_timeout, const unsigned char band, l1cal_rampTable_T  *ramp);
META_RESULT  __stdcall META_Rf_GetTXPCSubbandCompensationEPSK(unsigned int ms_timeout, const unsigned char band, l1cal_rampTable_T  *ramp);
META_RESULT  __stdcall META_Rf_GetTXPCSubbandCompensationEPSK_r(const int meta_handle, unsigned int ms_timeout, const unsigned char band, l1cal_rampTable_T  *ramp);

typedef struct
{
    short w_re[19];
    short w_im[19];
}RF_AvgW_Coef_T;

META_RESULT  __stdcall META_Rf_GetSpecialCoef(unsigned int ms_timeout, unsigned int rfid, void *coef_struct);
META_RESULT  __stdcall META_Rf_GetSpecialCoef_r(const int meta_handle, unsigned int ms_timeout, unsigned int rfid, void *coef_struct);

META_RESULT  __stdcall META_Rf_NSFT_ConfigSBER(unsigned int ms_timeout, const unsigned int test_frame_count);
META_RESULT  __stdcall META_Rf_NSFT_ConfigSBER_r(const int meta_handle, unsigned int ms_timeout, const unsigned int test_frame_count);
typedef struct
{
    unsigned int m_u4NSFTSBERSum;
    unsigned int m_u4NSFTSBERCurrentCount;
}RF_NSFT_SBERResult_T;

META_RESULT  __stdcall META_Rf_NSFT_GetSBER(unsigned int ms_timeout, RF_NSFT_SBERResult_T* sber_result);
META_RESULT  __stdcall META_Rf_NSFT_GetSBER_r(const int meta_handle, unsigned int ms_timeout, RF_NSFT_SBERResult_T* sber_result);
META_RESULT  __stdcall META_Rf_NSFT_StartRxLevel(unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_NSFT_StartRxLevel_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_NSFT_GetRxLevel(unsigned int ms_timeout, unsigned short *rx_level);
META_RESULT  __stdcall META_Rf_NSFT_GetRxLevel_r(const int meta_handle, unsigned int ms_timeout, unsigned short *rx_level);
META_RESULT  __stdcall META_Rf_NSFT_GetRxQual(unsigned int ms_timeout, const unsigned short ber_decile, unsigned char *rx_qual);
META_RESULT  __stdcall META_Rf_NSFT_GetRxQual_r(const int meta_handle, unsigned int ms_timeout, const unsigned short ber_decile, unsigned char *rx_qual);

//--------------------------------------------------------------------------//
//  NVRAM                                                                   //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  NVRAM: data structure definition                   //
//-----------------------------------------------------//

// Reset NVRAM
typedef enum 
{
	NVRAM_RESET_ALL,		// Reset all data items in both of user and system category
	NVRAM_RESET_USER,		// Reset data items in user category    --> obsolete! just keep the enum value for backward compatibility.
	NVRAM_RESET_SYSTEM,		// Reset data items in system category  --> obsolete! just keep the enum value for backward compatibility.
	NVRAM_RESET_CERTAIN,	// Reset certain data item according to LID
	NVRAM_RESET_FACTORY		// Reset to factory default value, all the LIDs has FACTORY attribute will be reseted 
} ResetCategory;   

typedef struct
{
	ResetCategory	category;	// Reset category

	const char		*LID;		// The name of logical data item ID , it will be used
								// if and only if ResetCategory = NVRAM_RESET_CERTAIN,
								// in other case you can just assign NULL.
} FT_NVRAM_RESET_REQ;

typedef struct
{
	unsigned char	status;		// The status of Reset
} FT_NVRAM_RESET_CNF;

// Read from NVRAM
typedef struct
{
	const char			*LID;		// The name of logical data item ID
	unsigned short 		RID;		// Record ID (the first record is 1)
} FT_NVRAM_READ_REQ;

typedef struct
{
	unsigned short		LID;		// Logical data item ID of a EF
	unsigned short		RID;		// Record ID (the first record is 1)
	unsigned char		status;		// 0: read ok; others: read failed.

	unsigned int		len;		// [IN] Length of Buffer, [OUT] Length of read data
									// The "len" field indicates the size of "buf" you 
									// allocated. When the data is read back, "len" will
									// be replaced with the actual size of the data.

	unsigned char 		*buf;		// Buffer that will contains the content of record
} FT_NVRAM_READ_CNF;

//Write to NVRAM
typedef struct
{
	const char			*LID;		// The name of logical data item ID
	unsigned short		RID;		// Record ID (the first record is 1)
	unsigned int		len;		// Length of write data
	unsigned char		*buf;		// Buffer that contains the content of record
} FT_NVRAM_WRITE_REQ;

typedef struct
{
	unsigned short		LID;		// Logical data item ID of a EF
	unsigned short		RID;		// Record ID (the first record is 1)
	unsigned char		status;		// 0: write ok; others: write failed.
} FT_NVRAM_WRITE_CNF;

// AGC path loss 
#define  PLTABLE_SIZE  13			// element count of path loss table

typedef  struct
{
   short        max_arfcn;			// The maximum ARFCN of the indicated sub-band
   char			gain_offset;		// The maximum available gain of transceiver of the indicated sub-band
} sAGCGAINOFFSET;

typedef struct
{
   sAGCGAINOFFSET     agcPathLoss[FrequencyBandCount][PLTABLE_SIZE];
}l1cal_agcPathLoss_T;

// Speech Coefficient
typedef struct {
	short		Speech_8k_Input_Coeff[30];		// FIR for input speech (microphone) with 8k sampling rate  
	short		Speech_8k_Output_Coeff[30];		// FIR for output speech (speaker) with 8k sampling rate    
	short		Speech_16k_Input_Coeff[62];		// FIR for input speech (microphone) with 16k sampling rate 
	short		Speech_16k_Output_Coeff[62];	// FIR for output speech (speaker) with 16k sampling rate   

	short		Additional_Speech_8k_Output_Coeff[5][30];	// The additional FIR for output speech (speaker) with 8k sampling rate 

	unsigned short	Speech_8k_Output_Coeff_Index;	// The active FIR index                      
													// 0 -> Speech_8k_Output_Coeff               
													// 1 -> Additional_Speech_8k_Output_Coeff[0] 
													// 2 -> Additional_Speech_8k_Output_Coeff[1] 
													// 3 -> Additional_Speech_8k_Output_Coeff[2] 
													// 4 -> Additional_Speech_8k_Output_Coeff[3] 
													// 5 -> Additional_Speech_8k_Output_Coeff[4] 
}L1_SpeechCoeff_T;

// Melody Coefficient
typedef struct {
	short		Melody_32k_Output_Coeff[45];	// FIR for melody playback with with 32k sampling rate 
}L1_MelodyCoeff_T;

// L1Audio Param
typedef struct{
	L1_SpeechCoeff_T	Speech_FIR[2];	// [0]: normal mode 
										// [1]: headset mode 
										// NOTE: In headset mode, Additional_Speech_8k_Output_Coeff and 
										//       Speech_8k_Output_Coeff_Index are ignored! you can just 
										//       leave them alone.                                      

	L1_MelodyCoeff_T	Melody_FIR[2];	// [0]: loud speaker mode 
										// [1]: stereo speaker mode 
	unsigned short		ES_TimeConst;
	unsigned short		ES_VolConst;
	unsigned short		ES_TimeConst2;
	unsigned short		ES_VolConst2;
	unsigned short		Media_Playback_Maximum_Swing;
}l1audio_param_T;

// L1Audio Param from W0547 

#define SPEECH_NORMAL_MODE			0
#define SPEECH_EARPHONE_MODE		1
#define SPEECH_LOUDSPEAKER_MODE		2
#define SPEECH_BT_ERAPHONE_MODE		3
#define SPEECH_BT_CORDLESS_MODE		4
#define SPEECH_AUX1_MODE			5
#define SPEECH_AUX2_MODE			6
#define SPEECH_AUX3_MODE			7

typedef struct{
	L1_SpeechCoeff_T	Speech_FIR[2];	// [0]: normal mode 
										// [1]: headset mode 
										// NOTE: In headset mode, Additional_Speech_8k_Output_Coeff and 
										//       Speech_8k_Output_Coeff_Index are ignored! you can just 
										//       leave them alone.                                      

	L1_MelodyCoeff_T	Melody_FIR[2];	// [0]: loud speaker mode 
										// [1]: stereo speaker mode 

	unsigned short		Speech_Common_Para[12];

	unsigned short		Speech_ModeDependent_Para[8][8];	// [0]: Normal Mode             
															// [1]: Earphone Mode           
															// [2]: Loud Speaker Mode       
															// [3]: BlueTooth Earphone Mode 
															// [4]: BlueTooth Cordless Mode 
															// [5]: AUX1 Mode               
															// [6]: AUX2 Mode               
															// [7]: AUX3 Mode               
	unsigned short		Media_Playback_Maximum_Swing;
} l1audio_param_W0547_T;


typedef struct{
	short speech_input_FIR_coeffs[6][45];
    short speech_output_FIR_coeffs[6][45];
    unsigned short selected_FIR_output_index;
    unsigned short speech_common_para[12];
    unsigned short speech_normal_mode_para[8];
    unsigned short speech_earphone_mode_para[8];
    unsigned short speech_loudspk_mode_para[8];
    unsigned short speech_bt_earphone_mode_para[8];
    unsigned short speech_bt_cordless_mode_para[8];
    unsigned short speech_aux1_mode_para[8];
    unsigned short speech_aux2_mode_para[8];
    unsigned short speech_aux3_mode_para[8];
    unsigned short Media_Playback_Maximum_Swing;
    short Melody_FIR_Output_Coeff_32k_Tbl1[45];
} l1audio_param_W0547_45_T;

typedef struct{
	short speech_input_FIR_coeffs[6][45];
    short speech_output_FIR_coeffs[6][45];
    unsigned short selected_FIR_output_index;
    unsigned short speech_common_para[12];
    unsigned short speech_normal_mode_para[8];
    unsigned short speech_earphone_mode_para[8];
    unsigned short speech_loudspk_mode_para[8];
    unsigned short speech_bt_earphone_mode_para[8];
    unsigned short speech_bt_cordless_mode_para[8];
    unsigned short speech_aux1_mode_para[8];
    unsigned short speech_aux2_mode_para[8];
    unsigned short speech_aux3_mode_para[8];
    unsigned short Media_Playback_Maximum_Swing;
    short Melody_FIR_Output_Coeff_32k_Tbl1[25];
} l1audio_param_W0712_T;


typedef struct
{
    short          speech_input_FIR_coeffs[6][45];
    short          speech_output_FIR_coeffs[6][45];
    unsigned short selected_FIR_output_index;
    unsigned short speech_common_para[12];
    unsigned short speech_mode_para[8][8];
    unsigned short Media_Playback_Maximum_Swing;
    short          Melody_FIR_Coeff_Tbl[25];
    short          audio_compensation_coeff[2][45];  // new added, so different with others structure

} l1audio_param_W0740_T;


typedef struct
{
    short          speech_input_FIR_coeffs[6][45];
    short          speech_output_FIR_coeffs[6][45];
    unsigned short selected_FIR_output_index;
    unsigned short speech_common_para[12];
    unsigned short speech_mode_para[8][16];
    unsigned short speech_volume_para[3][7][4];
    unsigned short Media_Playback_Maximum_Swing;
    short          Melody_FIR_Coeff_Tbl[25];
    short          audio_compensation_coeff[2][45];  // new added, so different with others structure

} l1audio_param_W0809_T; //l1audio_param_W0748_T;


typedef struct
{
    short          speech_input_FIR_coeffs[6][45];
    short          speech_output_FIR_coeffs[6][45];
    unsigned short selected_FIR_output_index;
    unsigned short speech_common_para[12];
    unsigned short speech_mode_para[8][16];
    unsigned short speech_volume_para[3][7][4];
    unsigned short Media_Playback_Maximum_Swing;
    short          Melody_FIR_Coeff_Tbl[25];
    short          audio_compensation_coeff[3][45];  // three ACFs for special branches in w10.18

} l1audio_param_EX_T;  // from W10.21

typedef struct 
{           
    // Volume
    short vol_calibration_shift[8];
    short vol_calibration_subband[8];
    // Delay
    short delay_cal_int;
    short delay_cal_frac;
    short delay_cal_subband[8];
    // Leakage
    short power_ratio_scale;
    short wind_index_threshold;
    short subband_bmg[8];
    // Mockup Diagnosis
    short mockup_level;
    short nr_level;
    short shielding_level;
    // Reserve
    short reserve[5];
} L1_audio_abf_param_struct_T;

typedef struct
{
    short          speech_input_FIR_coeffs[6][45];
    short          speech_output_FIR_coeffs[6][45];
    unsigned short selected_FIR_output_index;
    unsigned short speech_common_para[12];
    unsigned short speech_mode_para[8][16];
    unsigned short speech_volume_para[3][7][4];
    unsigned short Media_Playback_Maximum_Swing;
    short          Melody_FIR_Coeff_Tbl[25];
    short          audio_compensation_coeff[3][45];
    L1_audio_abf_param_struct_T  abf_param;
} l1audio_param_EX2_T;  // from W10.52

typedef struct
{
    short audio_compensation_filter_sw_ver_coeffs[3][3][45];
} l1audio_swfir_T;

// crystalAfcData
#define XO_SlopeArea_Num       33  // change from 8 to 33, 8 is obsolete

typedef struct {
	int		min_freq;
	short	min_dac;
	//int		inv_slope;
}XO_SLOPE_AREA_DATA;

typedef struct {  
	XO_SLOPE_AREA_DATA		XO_SlopeAreaData[XO_SlopeArea_Num]; 
}l1cal_crystalAfcData_T;

// IMEISV
typedef struct {
	char			imei[16];
	unsigned char	svn;
	unsigned char	pad;
}IMEISV_struct_T;

// Custom Acoustic Volume
#define MAX_VOL_CATE		3
#define MAX_VOL_TYPE		7
#define MAX_VOL_LEVEL		7
typedef struct {
	unsigned char	volume_gain[MAX_VOL_CATE][MAX_VOL_TYPE][MAX_VOL_LEVEL];
	// Volume Gain:	[Mode (Normal, Headset, LoudSpeaker)]									
	//				[Tone type (CallTone, Keytone, MIC, GMI, Speech, SideTone, Melody) ]	
	//				[Level (1~7)]															

	unsigned char	volume[MAX_VOL_CATE][MAX_VOL_TYPE];
	// Current Volume Level:	[Mode (Normal, Headset, LoudSpeaker)]									
	//							[Tone type (CallTone, Keytone, MIC, GMI, Speech, SideTone, Melody) ]	
	//							value: 0~6 [ Level_1(0) ~ Level_7(6) ]
   	
} CustAcousticVol_T;
typedef struct {
	unsigned char	volume_gain[MAX_VOL_CATE][MAX_VOL_TYPE][MAX_VOL_LEVEL];
	// Volume Gain:	[Mode (Normal, Headset, LoudSpeaker)]									
	//				[Tone type (CallTone, Keytone, MIC, GMI, Speech, SideTone, Melody) ]	
	//				[Level (1~7)]															

	unsigned char	volume[MAX_VOL_CATE][MAX_VOL_TYPE];
	// Current Volume Level:	[Mode (Normal, Headset, LoudSpeaker)]									
	//							[Tone type (CallTone, Keytone, MIC, GMI, Speech, SideTone, Melody) ]	
	//							value: 0~6 [ Level_1(0) ~ Level_7(6) ]
   	unsigned char max_melody_volume_gain[MAX_VOL_CATE + 1];
    unsigned char melody_volume_gain_step[MAX_VOL_CATE + 1];
    unsigned char tv_out_volume_gain[MAX_VOL_LEVEL];
} CustAcousticVol16lvl_T;

// S/W Change 
typedef enum {
	LID_VER_SAME = 0,
	LID_VER_CHANGED
}LID_STATUS;

typedef struct {
	int		OldVer;
	int		NewVer;
	char	LID[64];
}LID_Info;

typedef struct {
   int		target_nvramsize;	// current NVRAM size on target FAT file system
   int		target_freespace;	// current freespace of target FAT file system
   int		target_overhead;	// S/W upgrade operation overhead
   int		newdb_nvramsize;	// new NVRAM size
   unsigned char	status;		// 0 -> [OK] safe to upgrade to new NVRAM
   								// 1 -> [ERROR] can't retrieve info from target
   								// 2 -> [ERROR] freespace is not enough to upgrade to new NVRAM
} NVRAM_GetDiskInfo_Cnf;

// WiFi 
typedef struct {
	unsigned char	mac_addr[6];
} WiFi_MacAddress_S;

typedef struct {
	unsigned char	CCKTxPWR[14]; 
	unsigned char	OFDMTxPWR[14]; 
} WiFi_TxPower_2400M_S;

typedef struct {
	unsigned char	TxPWR[34]; 
} WiFi_TxPower_5000M_S;

typedef struct {
	unsigned char	i_ch_offset;
	unsigned char	q_ch_offset;
} WiFi_DAC_DC_Offset_S;

typedef struct {
	unsigned char txAlcCCK[14];
    unsigned char txOutputPowerDBCCK[14];
    unsigned char txAlcOFDM [8][14];
    unsigned char txOutputPowerDBOFDM[8][14];
} WiFi_ALC_2400M_S;

typedef struct
{
    unsigned char alcSlop1Divider;
    unsigned char alcSlop1Dividend;
    unsigned char alcSlop2Divider;
    unsigned char alcSlop2Dividend;
} WiFi_TxALC_2400M_S;
typedef struct
{
   unsigned char BluetoothAddress[6];
   unsigned char MinEncryptionSize[1];
   unsigned char MaxEncryptionSize[1];
   unsigned char HCITransportLayerParameters[3];
   unsigned char FixedPIN[16];
   unsigned char FixedPINLength[1];
   unsigned char SleepEnableMask[1];
   unsigned char LowPowerClockParameter[8];
   unsigned char PowerControlConfiguration[13];
   unsigned char SleepControlParameters[12];
   unsigned char DebugControl[4];
   unsigned char LCandRMOverrideEnable[4];
   unsigned char RadioRegisterOverride[6];
   unsigned char CodecConfiguration[8];
   unsigned char CVSDGainVolumeSettings[6];
   unsigned char VoiceSettings[2];
   unsigned char UserBaudRate[3];

   unsigned char LowPowerDriftRate[1];
   unsigned char MaxTxPowerLevel[1];
   unsigned char AdaptiveFrequencyHoppingParameters[29];
   unsigned char BufferSize[4];
   unsigned char GpioMapping[16];
   unsigned char GpioPolarity[4];
}  nvram_ef_btradio_rfmd3500_struct;

typedef struct
{
    unsigned char BDAddr[6];
    unsigned char ClassOfDevice[3];
    unsigned char LinkKeyType[1];
    unsigned char UnitKey[16];
    unsigned char Encryption[3];
    unsigned char PinCodeType[1];
    unsigned char Voice[2];
    unsigned char Codec[1];
    unsigned char Radio[30];
    unsigned char Sleep[6];
    unsigned char MainOscillatorInfo[5];
    unsigned char LPOInfo[4];
    unsigned char AFH[9];
    unsigned char PTA[49];
    unsigned char WDT[2];
    unsigned char Debug[1];
    unsigned char UART[2];
}  nvram_ef_btradio_mt6601_struct;

// this is common for MT6611/MT6612/MT6236
typedef struct
{
    unsigned char BDAddr[6];
    unsigned char CapId[1];
    unsigned char LinkKeyType[1];
    unsigned char UnitKey[16];
    unsigned char Encryption[3];
    unsigned char PinCodeType[1];
    unsigned char Voice[2];
    unsigned char Codec[1];
    unsigned char Radio[6];
    unsigned char Sleep[7];
    unsigned char Reserved[2];
}nvram_ef_btradio_mt6611_struct;


typedef struct // LID: NVRAM_EF_WNDRV_EXT_SETTING_TRIMVAL_THERMOVAL_LID
{
   char           cAbsTemp;
   unsigned char  ucThermoValue; 
   unsigned char  ucXtalTrim;
}wndrv_cal_setting_trim_thermo_struct;

typedef struct
{
    unsigned short tst_port_ps;
    unsigned short         ps_port;	
    unsigned int      tst_baudrate_ps;
    unsigned int      ps_baudrate;
    bool           High_Speed_SIM_Enabled;
    unsigned char          swdbg;	
    unsigned char          uart_power_setting; /* For DCM, Start [Set UART POWER], CTI  */
    unsigned char          cti_uart_port;
    unsigned int      cti_baudrate;
    unsigned char           tst_port_l1;
    unsigned int       tst_baudrate_l1;
    // Support tst output to memory card
    unsigned char          tst_output_mode;
    unsigned char  usb_logging_mode;
} port_setting_struct;
// from: mcu\interface\hwdrv\uart_sw.h

//-----------------------------------------------------//
//  NVRAM: callback function definition                //
//-----------------------------------------------------//
typedef void (__stdcall *META_NVRAM_Reset_CNF)(const FT_NVRAM_RESET_CNF *cnf, const short token, void *usrData);
typedef void (__stdcall *META_NVRAM_Read_CNF)(const FT_NVRAM_READ_CNF *cnf, const short token, void *usrData);
typedef void (__stdcall *META_NVRAM_Write_CNF)(const FT_NVRAM_WRITE_CNF *cnf, const short token, void *usrData);
typedef void (__stdcall *CB_META_NVRAM_GET_DISK_INFO_CNF)(const NVRAM_GetDiskInfo_Cnf *cnf, const short token, void *usrData);

//-----------------------------------------------------//
//  NVRAM: exported function definition                //
//-----------------------------------------------------//
META_RESULT  __stdcall META_NVRAM_Init(const char *PathName, unsigned long *p_nvram_CatcherTranAddr);
META_RESULT  __stdcall META_NVRAM_Init_r(const int meta_handle,const char *PathName, unsigned long *p_nvram_CatcherTranAddr);
META_RESULT  __stdcall META_NVRAM_Reset(const FT_NVRAM_RESET_REQ *req, const META_NVRAM_Reset_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_NVRAM_Reset_r(const int meta_handle, const FT_NVRAM_RESET_REQ *req, const META_NVRAM_Reset_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_NVRAM_Read(const FT_NVRAM_READ_REQ *req, FT_NVRAM_READ_CNF *cnf, const META_NVRAM_Read_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_NVRAM_Read_r(const int meta_handle, const FT_NVRAM_READ_REQ *req, FT_NVRAM_READ_CNF *cnf, const META_NVRAM_Read_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_NVRAM_Write(const FT_NVRAM_WRITE_REQ *req, const META_NVRAM_Write_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_NVRAM_Write_r(const int meta_handle, const FT_NVRAM_WRITE_REQ *req, const META_NVRAM_Write_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_NVRAM_GetAllLIDNameLength(int *len);
META_RESULT  __stdcall META_NVRAM_GetAllLIDName(char *buf, const int buf_len, int *NofLID);
META_RESULT  __stdcall META_NVRAM_GetLIDVersion(const char *LID,unsigned short *ver);
META_RESULT  __stdcall META_NVRAM_GetRecStructNameLength(const char *LID, int *len);
META_RESULT  __stdcall META_NVRAM_GetRecStructName(const char *LID, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_GetAllRecFieldNameLength(const char *LID, int *len);
META_RESULT  __stdcall META_NVRAM_GetAllRecFieldName(const char *LID, char *buf, const int buf_len, int *NofField);
META_RESULT  __stdcall META_NVRAM_CheckFieldNameExist(const char *LID, const char *Field, bool *result);
META_RESULT  __stdcall META_NVRAM_GetRecNum(const char *LID, int *num);
META_RESULT  __stdcall META_NVRAM_GetRecLen(const char *LID, int *len);
META_RESULT  __stdcall META_NVRAM_SetRecFieldValue(const char *LID, const char *field, char *buf, const int buf_len, void *value, const int value_len);
META_RESULT  __stdcall META_NVRAM_GetRecFieldValue(const char *LID, const char *field, const char *buf, const int buf_len, void *value, const int value_len);	
META_RESULT  __stdcall META_NVRAM_SetRecFieldBitValue(const char *LID, const char *field, const char *bitname, char *buf, const int buf_len, const int bitvalue);
META_RESULT  __stdcall META_NVRAM_GetRecFieldBitValue(const char *LID, const char *field, const char *bitname, const char *buf, const int buf_len, int *bitvalue);
META_RESULT  __stdcall META_NVRAM_QueryIsLIDExist(const char *LID);
META_RESULT  __stdcall META_NVRAM_ResetToFactoryDefault(unsigned int ms_timeout);
META_RESULT  __stdcall META_NVRAM_ResetToFactoryDefault_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_NVRAM_LockDown(unsigned int ms_timeout);
META_RESULT  __stdcall META_NVRAM_LockDown_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_NVRAM_OTP_LockDown(unsigned int ms_timeout);
META_RESULT  __stdcall META_NVRAM_OTP_LockDown_r(const int meta_handle, unsigned int ms_timeout);
// S/W Change 
META_RESULT  __stdcall META_NVRAM_SWC_RetrieveChangeList(void);
META_RESULT  __stdcall META_NVRAM_SWC_RetrieveChangeList_r(const int meta_handle);
META_RESULT  __stdcall META_NVRAM_SWC_UpdateChangeList(void);
META_RESULT  __stdcall META_NVRAM_SWC_UpdateChangeList_r(const int meta_handle);
META_RESULT  __stdcall META_NVRAM_SWC_GetAllChangedLIDCount(int *NofLID);
META_RESULT  __stdcall META_NVRAM_SWC_GetAllChangedLIDCount_r(const int meta_handle, int *NofLID);
META_RESULT  __stdcall META_NVRAM_SWC_GetAllChangedLIDName(LID_Info *p_ArrayOfLID, const int NofLID);
META_RESULT  __stdcall META_NVRAM_SWC_GetAllChangedLIDName_r(const int meta_handle, LID_Info *p_ArrayOfLID, const int NofLID);
META_RESULT  __stdcall META_NVRAM_SWC_QueryIfLIDChanged(const char *LID, LID_STATUS  *result);
META_RESULT  __stdcall META_NVRAM_SWC_QueryIfLIDChanged_r(const int meta_handle, const char *LID, LID_STATUS  *result);
META_RESULT  __stdcall META_NVRAM_SWC_ImportData(LID_Info *p_import_multiple_lid, int num_of_import_multiple_lid, int import_1st_sys_record_size );
META_RESULT  __stdcall META_NVRAM_SWC_ImportData_r(const int meta_handle, LID_Info *p_import_multiple_lid, int num_of_import_multiple_lid, int import_1st_sys_record_size );
META_RESULT  __stdcall META_NVRAM_SWC_Database_Compare(const char *PathName, int *p_NumOfNewAddLID, int *p_NumOfModifiedLID, int *p_NumOfDeletedLID);
META_RESULT  __stdcall META_NVRAM_SWC_Database_Compare_r(const int meta_handle, const char *PathName, int *p_NumOfNewAddLID, int *p_NumOfModifiedLID, int *p_NumOfDeletedLID);
META_RESULT  __stdcall META_NVRAM_SWC_Get_Database_Compare_Result(LID_Info *p_ArrayOfNewAddLID, const int NumOfNewAddLID, LID_Info *p_ArrayOfModifiedLID, const int NumOfModifiedLID, LID_Info *p_ArrayOfDeletedLID, const int NumOfDeletedLID);
META_RESULT  __stdcall META_NVRAM_SWC_Get_Database_Compare_Result_r(const int meta_handle, LID_Info *p_ArrayOfNewAddLID, const int NumOfNewAddLID, LID_Info *p_ArrayOfModifiedLID, const int NumOfModifiedLID, LID_Info *p_ArrayOfDeletedLID, const int NumOfDeletedLID);
META_RESULT  __stdcall META_NVRAM_SWC_Check_FAT_FreeSpace(const CB_META_NVRAM_GET_DISK_INFO_CNF  cb, short *token, void *usrData);
META_RESULT  __stdcall META_NVRAM_SWC_Check_FAT_FreeSpace_r(const int meta_handle, const CB_META_NVRAM_GET_DISK_INFO_CNF  cb, short *token, void *usrData);
META_RESULT  __stdcall META_NVRAM_SWC_Enable_ForceUpgrade(void);
META_RESULT  __stdcall META_NVRAM_SWC_Enable_ForceUpgrade_r(const int meta_handle);
META_RESULT  __stdcall META_NVRAM_SWC_Disable_ForceUpgrade(void);
META_RESULT  __stdcall META_NVRAM_SWC_Disable_ForceUpgrade_r(const int meta_handle);
// AGC path loss 
META_RESULT  __stdcall META_NVRAM_agcPathLoss_Len(int *len);
META_RESULT  __stdcall META_NVRAM_Compose_agcPathLoss(const l1cal_agcPathLoss_T *loss, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_agcPathLoss(l1cal_agcPathLoss_T *loss, const char *buf, const int buf_len);
// rampTable 
META_RESULT  __stdcall META_NVRAM_rampTable_Len(int *len);
META_RESULT  __stdcall META_NVRAM_Compose_rampTable(const l1cal_rampTable_T *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_rampTable(l1cal_rampTable_T *tbl, const char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_rampTable_Len_Ex(int *len);
META_RESULT  __stdcall META_NVRAM_Compose_rampTable_Ex(const l1cal_rampTable_T_Ex *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_rampTable_Ex(l1cal_rampTable_T_Ex *tbl, const char *buf, const int buf_len);

META_RESULT  __stdcall META_NVRAM_rampTable_Len_Ex2(int *len);
META_RESULT  __stdcall META_NVRAM_Compose_rampTable_Ex2(const l1cal_rampTable_T_Ex2 *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_rampTable_Ex2(l1cal_rampTable_T_Ex2 *tbl, const char *buf, const int buf_len);
// L1Audio Param
META_RESULT  __stdcall META_NVRAM_AudioParam_Len(int *len);
META_RESULT  __stdcall META_NVRAM_Compose_AudioParam(const l1audio_param_T *param, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioParam(l1audio_param_T *param, const char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_If_AudioParam_W0547_Support(void);
META_RESULT  __stdcall META_NVRAM_Compose_AudioParam_W0547(const l1audio_param_W0547_T *param, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioParam_W0547(l1audio_param_W0547_T *param, const char *buf, const int buf_len);

META_RESULT  __stdcall META_NVRAM_Compose_AudioParam_W0547_45(const l1audio_param_W0547_45_T *param, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioParam_W0547_45(l1audio_param_W0547_45_T *param, const char *buf, const int buf_len);

META_RESULT  __stdcall META_NVRAM_Compose_AudioParam_W0712(const l1audio_param_W0712_T *param, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioParam_W0712(l1audio_param_W0712_T *param, const char *buf, const int buf_len);


META_RESULT  __stdcall META_NVRAM_Decompose_AC_SWFIR_Param(l1audio_swfir_T *param, const char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Compose_AC_SWFIR_Param(const l1audio_swfir_T *param, char *buf, const int buf_len);
// L1Audio Param for WB
typedef struct
{
    short coeff[6][90];
}l1audio_wb_speech_fir_struct;

typedef struct
{
    short param[8][16];
}l1audio_wb_speech_mode_struct;

META_RESULT  __stdcall META_NVRAM_Compose_AudioFIRParam_WB(const l1audio_wb_speech_fir_struct *param, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioFIRParam_WB(l1audio_wb_speech_fir_struct *param, const char *buf, const int buf_len);

META_RESULT  __stdcall META_NVRAM_Compose_AudioSpeechParam_WB(const l1audio_wb_speech_mode_struct *param, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioSpeechParam_WB(l1audio_wb_speech_mode_struct *param, const char *buf, const int buf_len);


typedef struct
{
    unsigned int hsf_coeffs[9][4];
    unsigned int bpf_coeffs[4][6][3];
    /// BesLoudness V3
    unsigned int audio_besloudness_DRC_Forget_Table[9][2];
    unsigned int audio_besloudness_WS_Gain_Max;
    unsigned int audio_besloudness_WS_Gain_Min;
    unsigned int audio_besloudness_Filter_First;
    char         audio_besloudness_Gain_Map_In[5];
    char         audio_besloudness_Gain_Map_Out[5]; 
} l1audio_besloudness_T;

META_RESULT  __stdcall META_NVRAM_AudioBesLoudNess_Len(int *len);
META_RESULT  __stdcall META_NVRAM_Compose_AudioBesLoudNess(const l1audio_besloudness_T *param, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioBesLoudNess(l1audio_besloudness_T *param, const char *buf, const int buf_len);


// interRampData
META_RESULT  __stdcall META_NVRAM_interRampData_Len(int *len);
META_RESULT  __stdcall META_NVRAM_Compose_interRampData(const l1cal_interRampData_T *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_interRampData(l1cal_interRampData_T *tbl, const char *buf, const int buf_len);
// crystalAfcData
META_RESULT  __stdcall META_NVRAM_crystalAfcData_Len(int *len);
META_RESULT  __stdcall META_NVRAM_Compose_crystalAfcData(const l1cal_crystalAfcData_T *xo_afc, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_crystalAfcData(l1cal_crystalAfcData_T *xo_afc, const char *buf, const int buf_len);
// IMEISV
META_RESULT  __stdcall META_NVRAM_Calculate_IMEI_CD(const char *imei, unsigned short *p_cd);
META_RESULT  __stdcall META_NVRAM_IMEISV_Len(int *len);
META_RESULT  __stdcall META_NVRAM_Compose_IMEISV(const IMEISV_struct_T  *p_imeisv, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Compose_IMEISV_NoCheck(const IMEISV_struct_T  *p_imeisv, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Compose_IMEISV_ex(const IMEISV_struct_T  *p_imeisv, char *buf, const int buf_len,bool DoCheckSum);
META_RESULT  __stdcall META_NVRAM_Decompose_IMEISV(IMEISV_struct_T  *p_imeisv, const char *buf, const int buf_len);
// Custom Acoustic Volume
META_RESULT  __stdcall META_NVRAM_CustAcousticVol_Len(int *len);
META_RESULT  __stdcall META_NVRAM_Compose_CustAcousticVol(const CustAcousticVol_T *cust_acoustic_vol, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_CustAcousticVol(CustAcousticVol_T *cust_acoustic_vol, const char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Compose_16lvlCustAcousticVol(const CustAcousticVol16lvl_T *cust_acoustic_vol, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_16lvlCustAcousticVol(CustAcousticVol16lvl_T *cust_acoustic_vol, const char *buf, const int buf_len);
// RF Module Configuration 
META_RESULT  __stdcall META_NVRAM_RFSpecialCoef_Len(int *len);
// Skyworks 
META_RESULT  __stdcall META_NVRAM_Compose_SKY74045_RFSpecialCoef(const RF_SKY74045_Coef_T *rf_mod_coef, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_SKY74045_RFSpecialCoef(RF_SKY74045_Coef_T *rf_mod_coef, const char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Compose_SKY74117_RFSpecialCoef(const RF_SKY74117_Coef_T *rf_mod_coef, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_SKY74117_RFSpecialCoef(RF_SKY74117_Coef_T *rf_mod_coef, const char *buf, const int buf_len);
// MT6139B 
META_RESULT  __stdcall META_NVRAM_Compose_MT6139B_RFSpecialCoef(const RF_MT6139B_Coef_T *rf_mod_coef, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_MT6139B_RFSpecialCoef(RF_MT6139B_Coef_T *rf_mod_coef, const char *buf, const int buf_len);
// MT6140
//META_RESULT  __stdcall META_NVRAM_Compose_MT6140tx_RFSpecialCoef(const mt6140tx *rf_mod_coef, char *buf, const int buf_len);
//META_RESULT  __stdcall META_NVRAM_Decompose_MT6140tx_RFSpecialCoef(mt6140tx *rf_mod_coef, const char *buf, const int buf_len);

META_RESULT  __stdcall META_NVRAM_Compose_MT6140tx_PaVbias(const mt6140tx *pavbias, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_MT6140tx_PaVbias(mt6140tx *pavbias, const char *buf, const int buf_len);

// Renesas Bright5P 
META_RESULT  __stdcall META_NVRAM_Compose_BRIGHT5P_RFSpecialCoef(const RF_BRIGHT5P_Coef_T *rf_mod_coef, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_BRIGHT5P_RFSpecialCoef(RF_BRIGHT5P_Coef_T *rf_mod_coef, const char *buf, const int buf_len);
// EPSK interRampData 
META_RESULT  __stdcall META_NVRAM_EPSK_interRampData_Len(int *len);
META_RESULT  __stdcall META_NVRAM_Compose_EPSK_interRampData(const l1cal_EPSK_interRampData_T *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_EPSK_interRampData(l1cal_EPSK_interRampData_T *tbl, const char *buf, const int buf_len);
// TX power rollback table
META_RESULT  __stdcall META_NVRAM_TX_Rollback_Len(int *len);
META_RESULT  __stdcall META_NVRAM_Compose_TX_Rollback(const l1cal_tx_power_rollback_T *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_TX_Rollback(l1cal_tx_power_rollback_T *tbl, const char *buf, const int buf_len);

META_RESULT  __stdcall META_NVRAM_ClosedLoopTXPC_Len(int *len);
META_RESULT  __stdcall META_NVRAM_Compose_ClosedLoopTXPC(const l1cal_txpc_T *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_ClosedLoopTXPC(l1cal_txpc_T *tbl, const char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Compose_AvgW_RFSpecialCoef(const RF_AvgW_Coef_T *rf_mod_coef, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AvgW_RFSpecialCoef(RF_AvgW_Coef_T *rf_mod_coef, const char *buf, const int buf_len);

// WiFi 
META_RESULT  __stdcall META_NVRAM_WiFi_MacAddress_Len(int *len);
META_RESULT  __stdcall META_NVRAM_WiFi_Compose_MacAddress(const WiFi_MacAddress_S  *mac, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_Decompose_MacAddress(WiFi_MacAddress_S  *mac, const char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_TxPower2400M_Len(int *len);
META_RESULT  __stdcall META_NVRAM_WiFi_Compose_TxPower2400M(const WiFi_TxPower_2400M_S  *txpwr, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_Decompose_TxPower2400M(WiFi_TxPower_2400M_S  *txpwr, const char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_TxPower5000M_Len(int *len);
META_RESULT  __stdcall META_NVRAM_WiFi_Compose_TxPower5000M(const WiFi_TxPower_5000M_S  *txpwr, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_Decompose_TxPower5000M(WiFi_TxPower_5000M_S  *txpwr, const char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_DacDcOffset_Len(int *len);
META_RESULT  __stdcall META_NVRAM_WiFi_Compose_DacDcOffset(const WiFi_DAC_DC_Offset_S  *dac, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_Decompose_DacDcOffset(WiFi_DAC_DC_Offset_S  *dac, const char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_Compose_ALC_2400M(const WiFi_ALC_2400M_S  *alc, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_Decompose_ALC_2400M(WiFi_ALC_2400M_S  *alc, const char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_ALC_2400M_Len(int *len);

META_RESULT  __stdcall META_NVRAM_WiFi_TxALC2400M_Len(int *len);
META_RESULT  __stdcall META_NVRAM_WiFi_Compose_TxALC2400M(const WiFi_TxALC_2400M_S  *txalc, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_Decompose_TxALC2400M(WiFi_TxALC_2400M_S  *txalc, const char *buf, const int buf_len);

#ifdef __META_DLL_WCDMA__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif //#ifdef __META_DLL_WCDMA__
//BT
META_RESULT  __stdcall META_NVRAM_BT_Compose_RFMD3500Radio(const nvram_ef_btradio_rfmd3500_struct  *radio, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_BT_Decompose_RFMD3500Radio(nvram_ef_btradio_rfmd3500_struct  *radio, const char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_BT_Compose_MT6601Radio(const nvram_ef_btradio_mt6601_struct  *radio, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_BT_Decompose_MT6601Radio(nvram_ef_btradio_mt6601_struct  *radio, const char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_BT_Compose_MT6611Radio(const nvram_ef_btradio_mt6611_struct  *radio, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_BT_Decompose_MT6611Radio(nvram_ef_btradio_mt6611_struct  *radio, const char *buf, const int buf_len);



// sBBTxParameters
META_RESULT  __stdcall META_NVRAM_BBTXParameters_Len(int *len);
META_RESULT  __stdcall META_NVRAM_Compose_BBTXParameters(const BBTXParameters_T *bbtx, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_BBTXParameters(BBTXParameters_T *bbtx, const char *buf, const int buf_len);

//l1audio_param_W0740_T
META_RESULT  __stdcall META_NVRAM_Compose_AudioParam_W0740(const l1audio_param_W0740_T *param, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioParam_W0740(l1audio_param_W0740_T *param, const char *buf, const int buf_len);

// l1audio_param_W0809_T
META_RESULT  __stdcall META_NVRAM_Compose_AudioParam_W0809(const l1audio_param_W0809_T *param, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioParam_W0809(l1audio_param_W0809_T *param, const char *buf, const int buf_len);

// l1audio_param_EX_T
META_RESULT  __stdcall META_NVRAM_Compose_AudioParam_EX(const l1audio_param_EX_T *param, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioParam_EX(l1audio_param_EX_T *param, const char *buf, const int buf_len);

// l1audio_param_EX2_T
META_RESULT  __stdcall META_NVRAM_Compose_AudioParam_EX2(const l1audio_param_EX2_T *param, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioParam_EX2(l1audio_param_EX2_T *param, const char *buf, const int buf_len);

// ad6546tx
META_RESULT  __stdcall META_NVRAM_Compose_ad6546tx(const ad6546tx *adtx, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_ad6546tx(ad6546tx *adtx, const char *buf, const int buf_len);

//wndrv_cal_setting_trim_thermo_struct
META_RESULT  __stdcall META_NVRAM_TRIM_THERMO_Len(int *len);
META_RESULT  __stdcall META_NVRAM_WiFi_Compose_TrimThermo(const wndrv_cal_setting_trim_thermo_struct  *trim_struct, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_Decompose_TrimThermo(wndrv_cal_setting_trim_thermo_struct  *trim_struct, const char *buf, const int buf_len);


// PORT setting 
META_RESULT  __stdcall META_NVRAM_PortSetting_Len(int *len);
META_RESULT  __stdcall META_NVRAM_Compose_PortSetting(const port_setting_struct *port_setting, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_PortSetting(port_setting_struct *port_setting, const char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_GetAutoTestiFlagEnumValue(int *value);
META_RESULT  __stdcall META_NVRAM_SetAutoTestiFlag(void);

//META_RESULT  __stdcall META_NVRAM_Read_Ex(const FT_NVRAM_READ_REQ *req, FT_NVRAM_READ_CNF *cnf);
//META_RESULT  __stdcall META_NVRAM_Read_Ex_r(const int meta_handle, const FT_NVRAM_READ_REQ *req, FT_NVRAM_READ_CNF *cnf);
//META_RESULT  __stdcall META_NVRAM_Write_Ex(const FT_NVRAM_WRITE_REQ *req);
//META_RESULT  __stdcall META_NVRAM_Write_Ex_r(const int meta_handle, const FT_NVRAM_WRITE_REQ *req);

META_RESULT  __stdcall META_NVRAM_Read_Ex( const unsigned int  ms_timeout, const FT_NVRAM_READ_REQ *req, FT_NVRAM_READ_CNF *cnf);
META_RESULT  __stdcall META_NVRAM_Read_Ex_r( const int meta_handle, unsigned int  ms_timeout, const FT_NVRAM_READ_REQ *req, FT_NVRAM_READ_CNF *cnf);
META_RESULT  __stdcall META_NVRAM_Write_Ex(const unsigned int  ms_timeout, const FT_NVRAM_WRITE_REQ *req, FT_NVRAM_WRITE_CNF *cnf);
META_RESULT  __stdcall META_NVRAM_Write_Ex_r(const int meta_handle, const unsigned int  ms_timeout, const FT_NVRAM_WRITE_REQ *req, FT_NVRAM_WRITE_CNF *cnf);


//---------------------------------------------------------------------------//
//  ASTRONAUT: NVRAM                                                         //
//---------------------------------------------------------------------------//
#ifdef __META_DLL_TD_A__
#define TD_A_CAL_TEMP_SECTION 8
#define TD_A_CAL_UARFCN_SECTION 15
typedef struct
{
   unsigned short  tempdacData[TD_A_CAL_TEMP_SECTION];
}a_tl1cal_tempdacData_T; 
typedef struct
{
	 unsigned short initDac;
	 unsigned short slope;
}a_tl1cal_afcData_T;
typedef struct
{
   //short  pathLoss[3]; removed from w10.17
   unsigned short freqTable[TD_A_CAL_UARFCN_SECTION];
   short  compByFreq[3][TD_A_CAL_UARFCN_SECTION];
   short  compByTemp[3][TD_A_CAL_TEMP_SECTION];
}a_tl1cal_pathlossData_T;
typedef struct
{
   unsigned short paData[3][4];
   short          paPower[3][4];
   unsigned short freqTable[TD_A_CAL_UARFCN_SECTION];
   short          compByFreq[3][TD_A_CAL_UARFCN_SECTION];
   short          compByTemp[3][TD_A_CAL_TEMP_SECTION];  
   unsigned short paSwitch[2][2]; 
   short          maxPaPower;
   unsigned short maxPaData;
}a_tl1cal_txdacData_T;
META_RESULT  __stdcall META_NVRAM_TD_A_TempADC_Len(int *len);
META_RESULT  __stdcall META_NVRAM_Compose_TD_A_TempADC(const a_tl1cal_tempdacData_T *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_TD_A_TempADC(a_tl1cal_tempdacData_T *tbl, const char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_TD_A_AFCData_Len(int *len);
META_RESULT  __stdcall META_NVRAM_Compose_TD_A_AFCData(const a_tl1cal_afcData_T *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_TD_A_AFCData(a_tl1cal_afcData_T *tbl, const char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_TD_A_PathLossData_Len(int *len);
META_RESULT  __stdcall META_NVRAM_Compose_TD_A_PathLossData(const a_tl1cal_pathlossData_T *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_TD_A_PathLossData(a_tl1cal_pathlossData_T *tbl, const char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_TD_A_TxDacData_Len(int *len);
META_RESULT  __stdcall META_NVRAM_Compose_TD_A_TxDacData(const a_tl1cal_txdacData_T *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_TD_A_TxDacData(a_tl1cal_txdacData_T *tbl, const char *buf, const int buf_len);
#endif // end of #ifdef __META_DLL_TD_A__

//--------------------------------------------------------------------------//
//  Audio Testing                                                           //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  Audio Testing: data structure definition           //
//-----------------------------------------------------//

// audio testing result
typedef enum  {
	AUD_RES_OK = 0,						// OK 
	AUD_RES_FAIL,						// General Fail 
	AUD_RES_BUSY,						// system busy 
	AUD_RES_DISC_FULL,					// Memory full 
	AUD_RES_OPEN_FILE_FAIL,				// open file fail 
	AUD_RES_END_OF_FILE,				// play finish 
	AUD_ERR_OP_NOT_SUPPORT = 0xFB,       // added by ShuMin, for error handler enhancements// filepath too long
	AUD_ERR_STILL_PLAYING = 0xFC,       // added by ShuMin, because I found target had this error value
	AUD_ERR_PEER_BUF_ERROR = 0xFD,		// peer buf error 
	AUD_ERR_FILEPATH_ERROR = 0xFE,		// filepath error 
	AUD_ERR_FILEPATH_TOO_LONG = 0xFF	// filepath too long 
}AUDIO_RESULT;

// play style enum 
typedef enum {
	FT_L4AUD_AUDIO_PLAY_CRESCENDO = 0,	// Play sound for crescendo. 
	FT_L4AUD_AUDIO_PLAY_INFINITE,		// Play sound for infinite. 
	FT_L4AUD_AUDIO_PLAY_ONCE,			// Play sound for once. 
	FT_L4AUD_AUDIO_PLAY_DESCENDO		// Play sound for descendo. 
}AUDIO_PLAY_STYLE;

// default system embeded audio id query 
typedef struct {
	unsigned short		MinRingTone_ID;
	unsigned short		MaxRingTone_ID;
	unsigned short		MinMIDI_ID;
	unsigned short		MaxMIDI_ID;
	unsigned short		MinSound_ID;
	unsigned short		MaxSound_ID;
	AUDIO_RESULT		status;
}Audio_Query_ID_Cnf;

// play default system embeded audio by the given audio id 
typedef struct {
	unsigned short		audio_id;		// default system embeded audio id 
	AUDIO_PLAY_STYLE	play_style;		// play style 
}Audio_Play_Req;

// play audio from FAT by the given filepath 
typedef struct {
	const char			*fat_filepath;	// filepath on target FAT file system 
	AUDIO_PLAY_STYLE	play_style;		// play style 
}Audio_Play_ByName_Req;

// play imelody by the buffer from PC side 
typedef struct {
	const char			*imy_buf;		// buffer that stores iMelody content 
	unsigned int		imy_buf_len;	// length of buffer 
	unsigned char		imy_instrument;	// instrument id, 1 ~ 128 
	AUDIO_PLAY_STYLE	play_style;		// play style 
}Audio_Play_IMY_ByBuf_Req;

// play mp3 from FAT by the given filepath 
typedef struct {
	const char			*fat_filepath;	// filepath on target FAT file system 
	AUDIO_PLAY_STYLE	play_style;		// play style 
}Audio_MEDIA_Play_Req;

// set volume 
typedef struct {
	unsigned char		volume;			// play volume, 0 ~ 255 
}Audio_Set_Volume_Req;

typedef struct {
	unsigned char		echoflag;			// echofalg true
}Audio_Set_Echo_Req;

typedef struct {
	unsigned char		modeflag;			// modeflag: 0: normal, 1: headset, 2: loudspeaker  (totally 3 modes)
}Audio_Set_Mode_Req;

typedef struct {
	unsigned char		type;
	unsigned char		gain;
}Audio_Set_Gain_Req;

typedef struct {
	short		in_fir_coeffs[45];
	short		out_fir_coeffs[45];
}Audio_Set_LoudSpk_FIR_Coeffs_Req;

typedef struct {
	unsigned short speech_common_para[12];  // 8 or 12, so at most 12
}Audio_Set_Speech_Common_Req;

typedef struct {
	unsigned short speech_loudspk_mode_para[16];  // change from 8 to 16, because at most: 16
}Audio_Set_LoudSpk_Mode_Req;

typedef struct {
	unsigned short Media_Playback_Maximum_Swing;
}Audio_Set_Playback_Maximum_Swing_Req;

typedef struct {
	short Melody_FIR_Output_Coeff_32k_Tbl1[25];
}Audio_Set_Melody_FIR_Output_Coeffs_Req;

typedef struct {
	unsigned short speech_common_para[12];
	unsigned short speech_loudspk_mode_para[16];  // change from 8 to 16, because at most: 16
}Audio_Set_Speech_Common_And_Mode_Req;

typedef struct {
	unsigned short		fre;
	unsigned char		spkgain;
	unsigned char		micgain;
	unsigned short      ulgain; 
	unsigned short      dlgain;
	unsigned short      amp;
    
}Audio_Tone_LoopBackRec_Req;

typedef struct {
	unsigned int		buffer[2000];
}Audio_Tone_LoopBackRec_Cnf;

typedef struct {
	unsigned int		buffer[500];
}Audio_Tone_LoopBackRec_Cnf_2K;

typedef struct
{
	unsigned char  m_ucVolume;
	unsigned short m_u2Freq;
}Audio_Set_Freq_Vol_Tone_Req_T;

typedef struct
{
	unsigned char  m_ucMode;
}Audio_Get_Profile_Settings_By_Mode_Req_T;

typedef struct
{
	unsigned char mode;
    unsigned char melody[7];         
    unsigned char sound[7];          
    unsigned char keytone[7];         
    unsigned char speech[7];         
    unsigned char mic[7];           
    unsigned char sidetone;         
    unsigned char max_melody_volume_gain;
    unsigned char melody_volume_gain_step;
    unsigned char tv_out_volume_gain[MAX_VOL_LEVEL];  // 7 here

}Audio_Get_Profile_Settings_By_Mode_Cnf_T;

typedef struct
{
	unsigned char mode;
    unsigned char melody[7];         
    unsigned char sound[7];          
    unsigned char keytone[7];         
    unsigned char speech[7];         
    unsigned char mic[7];           
    unsigned char sidetone;         
    unsigned char max_melody_volume_gain;
    unsigned char melody_volume_gain_step;
    unsigned char tv_out_volume_gain[MAX_VOL_LEVEL];  // 7 here

}Audio_Set_Profile_Settings_By_Mode_Req_T;

typedef struct
{
    
    unsigned short m_u2FailReason;  // possible fail resons

}Audio_Set_Profile_Settings_By_Mode_Cnf_T;


typedef struct
{
    
    unsigned short m_u2FailReason;  // possible fail resons, (2 means the format is not matched with Target side)

}Audio_Set_Param_Cnf_T;

//-----------------------------------------------------//
//  Audio Testing: callback function definition        //
//-----------------------------------------------------//
typedef void (__stdcall *META_AUDIO_QUERY_ID_CNF)(const Audio_Query_ID_Cnf *cnf, const short token, void *usrData);
typedef void (__stdcall *META_AUDIO_PLAY_CNF)(const AUDIO_RESULT status, const short token, void *usrData);
typedef void (__stdcall *META_AUDIO_PLAY_BYNAME_CNF)(const AUDIO_RESULT status, const short token, void *usrData);
typedef void (__stdcall *META_AUDIO_PLAY_IMY_BYBUF_CNF)(const AUDIO_RESULT status, const short token, void *usrData);
typedef void (__stdcall *META_AUDIO_PLAY_OVER_IND)(const AUDIO_RESULT status, const short token, void *usrData);
typedef void (__stdcall *META_AUDIO_STOP_CNF)(const AUDIO_RESULT status, const short token, void *usrData);
typedef void (__stdcall *META_AUDIO_MEDIA_PLAY_CNF)(const AUDIO_RESULT status, const short token, void *usrData);
typedef void (__stdcall *META_AUDIO_MEDIA_PLAY_OVER_IND)(const AUDIO_RESULT status, const short token, void *usrData);
typedef void (__stdcall *META_AUDIO_MEDIA_STOP_CNF)(const AUDIO_RESULT status, const short token, void *usrData);
typedef void (__stdcall *META_AUDIO_SET_VOLUME_CNF)(const AUDIO_RESULT status, const short token, void *usrData);

//-----------------------------------------------------//
//  Audio Testing: exported function definition        //
//-----------------------------------------------------//
META_RESULT  __stdcall META_Audio_Query_ID(const META_AUDIO_QUERY_ID_CNF  cnf_cb, short *token, void *usrData);
META_RESULT  __stdcall META_Audio_Query_ID_r(const int meta_handle, const META_AUDIO_QUERY_ID_CNF  cnf_cb, short *token, void *usrData);
META_RESULT  __stdcall META_Audio_Play(const Audio_Play_Req  *req, const META_AUDIO_PLAY_CNF cnf_cb, const META_AUDIO_PLAY_OVER_IND  ind_cb, short *token, void *usrData);
META_RESULT  __stdcall META_Audio_Play_r(const int meta_handle, const Audio_Play_Req  *req, const META_AUDIO_PLAY_CNF cnf_cb, const META_AUDIO_PLAY_OVER_IND  ind_cb, short *token, void *usrData);
META_RESULT  __stdcall META_Audio_Play_ByName(const Audio_Play_ByName_Req  *req, const META_AUDIO_PLAY_BYNAME_CNF  cnf_cb, const META_AUDIO_PLAY_OVER_IND  ind_cb, short *token, void *usrData);
META_RESULT  __stdcall META_Audio_Play_ByName_r(const int meta_handle, const Audio_Play_ByName_Req  *req, const META_AUDIO_PLAY_BYNAME_CNF  cnf_cb, const META_AUDIO_PLAY_OVER_IND  ind_cb, short *token, void *usrData);
META_RESULT  __stdcall META_Audio_Play_IMY_ByBuf(const Audio_Play_IMY_ByBuf_Req  *req, const META_AUDIO_PLAY_IMY_BYBUF_CNF  cnf_cb, const META_AUDIO_PLAY_OVER_IND  ind_cb, short *token, void *usrData);
META_RESULT  __stdcall META_Audio_Play_IMY_ByBuf_r(const int meta_handle, const Audio_Play_IMY_ByBuf_Req  *req, const META_AUDIO_PLAY_IMY_BYBUF_CNF  cnf_cb, const META_AUDIO_PLAY_OVER_IND  ind_cb, short *token, void *usrData);
META_RESULT  __stdcall META_Audio_Stop(const META_AUDIO_STOP_CNF  cnf_cb, short *token, void *usrData);
META_RESULT  __stdcall META_Audio_Stop_r(const int meta_handle, const META_AUDIO_STOP_CNF  cnf_cb, short *token, void *usrData);
//META_RESULT  __stdcall META_Audio_MEDIA_Play(const Audio_MEDIA_Play_Req  *req, const META_AUDIO_MEDIA_PLAY_CNF  cnf_cb, const META_AUDIO_MEDIA_PLAY_OVER_IND  ind_cb, short *token, void *usrData);
//META_RESULT  __stdcall META_Audio_MEDIA_Play_r(const int meta_handle, const Audio_MEDIA_Play_Req  *req, const META_AUDIO_MEDIA_PLAY_CNF  cnf_cb, const META_AUDIO_MEDIA_PLAY_OVER_IND  ind_cb, short *token, void *usrData);
//META_RESULT  __stdcall META_Audio_MEDIA_Stop(const META_AUDIO_MEDIA_STOP_CNF  cnf_cb, short *token, void *usrData);
//META_RESULT  __stdcall META_Audio_MEDIA_Stop_r(const int meta_handle, const META_AUDIO_MEDIA_STOP_CNF  cnf_cb, short *token, void *usrData);
META_RESULT  __stdcall META_Audio_Set_Volume(const Audio_Set_Volume_Req  *req, const META_AUDIO_SET_VOLUME_CNF  cnf_cb, short *token, void *usrData);
META_RESULT  __stdcall META_Audio_Set_Volume_r(const int meta_handle, const Audio_Set_Volume_Req  *req, const META_AUDIO_SET_VOLUME_CNF  cnf_cb, short *token, void *usrData);
META_RESULT  __stdcall META_Audio_Set_Echo_Loop(unsigned int  ms_timeout,const Audio_Set_Echo_Req  *req);
META_RESULT  __stdcall META_Audio_Set_Echo_Loop_r(const int meta_handle,unsigned int  ms_timeout ,const Audio_Set_Echo_Req  *req);
META_RESULT  __stdcall META_Audio_Set_Mode(unsigned int  ms_timeout,const Audio_Set_Mode_Req  *req);
META_RESULT  __stdcall META_Audio_Set_Mode_r(const int meta_handle,unsigned int  ms_timeout ,const Audio_Set_Mode_Req  *req);
META_RESULT  __stdcall META_Audio_Set_Gain(unsigned int  ms_timeout,const Audio_Set_Gain_Req  *req);
META_RESULT  __stdcall META_Audio_Set_Gain_r(const int meta_handle,unsigned int  ms_timeout ,const Audio_Set_Gain_Req  *req);
META_RESULT  __stdcall META_Audio_Tone_Loop_Back_Rec(unsigned int  ms_timeout, Audio_Tone_LoopBackRec_Req  *req, Audio_Tone_LoopBackRec_Cnf *cnf);
META_RESULT  __stdcall META_Audio_Tone_Loop_Back_Rec_r(const int meta_handle,unsigned int  ms_timeout , Audio_Tone_LoopBackRec_Req  *req, Audio_Tone_LoopBackRec_Cnf *cnf);
//  for loud-speaker mode
META_RESULT  __stdcall META_Audio_Tone_Loop_Back_Rec_2K(unsigned int  ms_timeout, Audio_Tone_LoopBackRec_Req  *req, Audio_Tone_LoopBackRec_Cnf_2K *cnf);
META_RESULT  __stdcall META_Audio_Tone_Loop_Back_Rec_2K_r(const int meta_handle,unsigned int  ms_timeout , Audio_Tone_LoopBackRec_Req  *req, Audio_Tone_LoopBackRec_Cnf_2K *cnf);
// for normal mode
META_RESULT  __stdcall META_Audio_Tone_Loop_Back_Rec_2K_Normal(unsigned int  ms_timeout, Audio_Tone_LoopBackRec_Req  *req, Audio_Tone_LoopBackRec_Cnf_2K *cnf);
META_RESULT  __stdcall META_Audio_Tone_Loop_Back_Rec_2K_Normal_r(const int meta_handle,unsigned int  ms_timeout , Audio_Tone_LoopBackRec_Req  *req, Audio_Tone_LoopBackRec_Cnf_2K *cnf);

META_RESULT  __stdcall META_Audio_Set_LoudSpk_FIR_Coeffs(unsigned int  ms_timeout,const Audio_Set_LoudSpk_FIR_Coeffs_Req  *req);
META_RESULT  __stdcall META_Audio_Set_LoudSpk_FIR_Coeffs_r(const int meta_handle, unsigned int  ms_timeout,const Audio_Set_LoudSpk_FIR_Coeffs_Req  *req); 
META_RESULT  __stdcall META_Audio_Set_Speech_Common(unsigned int  ms_timeout,const Audio_Set_Speech_Common_Req  *req);
META_RESULT  __stdcall META_Audio_Set_Speech_Common_r(const int meta_handle, unsigned int  ms_timeout,const Audio_Set_Speech_Common_Req  *req);
META_RESULT  __stdcall META_Audio_Set_LoudSpk_Mode(unsigned int  ms_timeout,const Audio_Set_LoudSpk_Mode_Req  *req);
META_RESULT  __stdcall META_Audio_Set_LoudSpk_Mode_r(const int meta_handle, unsigned int  ms_timeout,const Audio_Set_LoudSpk_Mode_Req  *req);
META_RESULT  __stdcall META_Audio_Set_Playback_Maximum_Swing(unsigned int  ms_timeout,const Audio_Set_Playback_Maximum_Swing_Req  *req);
META_RESULT  __stdcall META_Audio_Set_Playback_Maximum_Swing_r(const int meta_handle, unsigned int  ms_timeout,const Audio_Set_Playback_Maximum_Swing_Req  *req);
META_RESULT  __stdcall META_Audio_Set_Melody_FIR_Output_Coeffs(unsigned int  ms_timeout,const Audio_Set_Melody_FIR_Output_Coeffs_Req  *req);
META_RESULT  __stdcall META_Audio_Set_Melody_FIR_Output_Coeffs_r(const int meta_handle, unsigned int  ms_timeout,const Audio_Set_Melody_FIR_Output_Coeffs_Req  *req);
META_RESULT  __stdcall META_Audio_Set_Speech_Common_And_Mode(unsigned int  ms_timeout,const Audio_Set_Speech_Common_And_Mode_Req  *req);
META_RESULT  __stdcall META_Audio_Set_Speech_Common_And_Mode_r(const int meta_handle, unsigned int  ms_timeout,const Audio_Set_Speech_Common_And_Mode_Req  *req);

META_RESULT  __stdcall META_Audio_Play_Freq_Vol_Tone(unsigned int  ms_timeout,const Audio_Set_Freq_Vol_Tone_Req_T  *req);
META_RESULT  __stdcall META_Audio_Play_Freq_Vol_Tone_r(const int meta_handle, unsigned int  ms_timeout,const Audio_Set_Freq_Vol_Tone_Req_T  *req);
META_RESULT  __stdcall META_Audio_Stop_Freq_Vol_Tone(unsigned int  ms_timeout);
META_RESULT  __stdcall META_Audio_Stop_Freq_Vol_Tone_r(const int meta_handle, unsigned int  ms_timeout);


META_RESULT  __stdcall META_Audio_Get_Audio_Profile_Settings(unsigned int ms_timeout,
								                             Audio_Get_Profile_Settings_By_Mode_Req_T *req, 
									                         Audio_Get_Profile_Settings_By_Mode_Cnf_T *cnf);
META_RESULT  __stdcall META_Audio_Get_Audio_Profile_Settings_r(const int meta_handle, 
															   unsigned int  ms_timeout, 
															   Audio_Get_Profile_Settings_By_Mode_Req_T *req, 
									                           Audio_Get_Profile_Settings_By_Mode_Cnf_T *cnf);
META_RESULT  __stdcall META_Audio_Set_Audio_Profile_Settings(unsigned int ms_timeout,
								                             Audio_Set_Profile_Settings_By_Mode_Req_T *req, 
									                         Audio_Set_Profile_Settings_By_Mode_Cnf_T *cnf);
META_RESULT  __stdcall META_Audio_Set_Audio_Profile_Settings_r(const int meta_handle, 
															   unsigned int  ms_timeout, 
															   Audio_Set_Profile_Settings_By_Mode_Req_T *req, 
									                           Audio_Set_Profile_Settings_By_Mode_Cnf_T *cnf);

META_RESULT  __stdcall META_Audio_Get_Audio_Param_Settings_0809(unsigned int ms_timeout,
									                         l1audio_param_W0809_T *cnf);
META_RESULT  __stdcall META_Audio_Get_Audio_Param_Settings_0809_r(const int meta_handle, 
															   unsigned int  ms_timeout,  
									                           l1audio_param_W0809_T *cnf) ;

META_RESULT  __stdcall META_Audio_Set_Audio_Param_Settings_0809(unsigned int ms_timeout,
									                         l1audio_param_W0809_T *req,
															 Audio_Set_Param_Cnf_T *cnf);

META_RESULT  __stdcall META_Audio_Set_Audio_Param_Settings_0809_r(const int meta_handle, 
															   unsigned int  ms_timeout,  
									                           l1audio_param_W0809_T *req,
															   Audio_Set_Param_Cnf_T *cnf);


META_RESULT  __stdcall META_Audio_Set_Output_Dev(unsigned int ms_timeout,
									             unsigned char *output_dev_req);

META_RESULT  __stdcall META_Audio_Set_Output_Dev_r(const int meta_handle,
												   unsigned int ms_timeout,
									               unsigned char *output_dev_req);
META_RESULT  __stdcall META_Audio_Set_Output_Vol(unsigned int ms_timeout,
									             unsigned char *output_vol);

META_RESULT  __stdcall META_Audio_Set_Output_Vol_r(const int meta_handle,
												   unsigned int ms_timeout,
									               unsigned char *output_vol);


typedef struct
{
	 unsigned char          u1_set_output_device;
	 unsigned short         u2_digital_gain;         
}Audio_SetOutputDevEx_Req_T; 


META_RESULT  __stdcall META_Audio_Set_Output_Dev_With_DG(unsigned int ms_timeout,
									               Audio_SetOutputDevEx_Req_T *req);

META_RESULT  __stdcall META_Audio_Set_Output_Dev_With_DG_r(const int meta_handle,
												   unsigned int ms_timeout,
									               Audio_SetOutputDevEx_Req_T *req);



META_RESULT  __stdcall META_Audio_FreeMemory(unsigned int ms_timeout);
META_RESULT  __stdcall META_Audio_FreeMemory_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_Audio_PlayCurMemContent(unsigned int ms_timeout);
META_RESULT  __stdcall META_Audio_PlayCurMemContent_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_Audio_StopPlaying(unsigned int ms_timeout);
META_RESULT  __stdcall META_Audio_StopPlaying_r(const int meta_handle, unsigned int ms_timeout);


typedef int (__stdcall *CALLBACK_META_AUDIO_PROGRESS)(unsigned char percent, int sent_bytes, int total_bytes, const short token, void *usr_arg);

typedef struct
{
   
   bool bCheckHdr;
   unsigned int u4StartFilePos; // only valid when bCheckHdr = false;

   char *pFilePath;

   bool bIsStereo;
   char i1BitPerSample;
   unsigned short u2SampleFreq;
   bool  bForceVoice;       // always set true?

   CALLBACK_META_AUDIO_PROGRESS  cb_progress; 
   void  *cb_progress_arg; 
   
   
}Audio_Play_Wave_File_REQ_T;



META_RESULT __stdcall META_Audio_Play_Wave_File(unsigned int ms_timeout, Audio_Play_Wave_File_REQ_T *req, int *pStopFlag, bool *bSaveAllOnTargetMem);
META_RESULT __stdcall META_Audio_Play_Wave_File_r(const int meta_handle, unsigned int ms_timeout, Audio_Play_Wave_File_REQ_T *req, int *pStopFlag, bool *bSaveAllOnTargetMem);


typedef enum
{
	AC_Filter_DSP_FIR = 0
    ,AC_Filter_HW_FIR
    ,AC_Filter_DSP_IIR
	,AC_Filter_UNKNOWN = 100
}E_Audio_Compensation_Filter_Type;

META_RESULT  __stdcall META_Audio_GetACFilterType(unsigned int ms_timeout, E_Audio_Compensation_Filter_Type *p_type);
META_RESULT  __stdcall META_Audio_GetACFilterType_r(const int meta_handle, unsigned int ms_timeout, E_Audio_Compensation_Filter_Type *p_type);

typedef struct
{
	unsigned char u1_ac_mode; // loudspeaker: 0, normal: 1
	short i2_ac_coef[45];
}Audio_Compensation_Filter_Coef;

META_RESULT  __stdcall META_Audio_SetACFilterCoef(unsigned int ms_timeout, const Audio_Compensation_Filter_Coef *p_req);
META_RESULT  __stdcall META_Audio_SetACFilterCoef_r(const int meta_handle, unsigned int ms_timeout, const Audio_Compensation_Filter_Coef *p_req);
META_RESULT  __stdcall META_Audio_GetGainTypeSupport(unsigned int ms_timeout);
META_RESULT  __stdcall META_Audio_GetGainTypeSupport_r(const int meta_handle, unsigned int ms_timeout);

typedef struct
{
   short          i2MaxGain; 
   unsigned short u2Step;
   unsigned short u2TotalLevel;
}Audio_Ex_GetDLGainCap_T;

typedef struct
{
	 unsigned int              u4_dl_buf_type_by_mode[4]; //0:handset, 1:headset, 2: handsfree, 3: bt earphone
	 Audio_Ex_GetDLGainCap_T   buf_info[2];               // 0: audio buffer, 1: voice buffer, 2: unknown
	 bool                      b_digital_gain_support;  
	 
	 
}Audio_Ex_GetDLGainCap_CNF_T; // stored in peer buffer


META_RESULT __stdcall META_Audio_EX_GetDLGainCapability(const unsigned int ms_timeout, Audio_Ex_GetDLGainCap_CNF_T *cnf);
META_RESULT __stdcall META_Audio_EX_GetDLGainCapability_r(const int meta_handle, const unsigned int ms_timeout, Audio_Ex_GetDLGainCap_CNF_T *cnf);


typedef struct
{
   
   unsigned int     iir_coeff_int[4][6][3]; 
   unsigned int     hsf_coeff_int[9][4];
}Audio_Ex_SetACFToTarget_REQ_T;

META_RESULT __stdcall META_Audio_EX_SetACFIIRToTarget(const unsigned int ms_timeout, Audio_Ex_SetACFToTarget_REQ_T *req);
META_RESULT __stdcall META_Audio_EX_SetACFIIRToTarget_r(const int meta_handle, const unsigned int ms_timeout, Audio_Ex_SetACFToTarget_REQ_T *req);

typedef struct
{
    /// the buffer for the compose function sink
    char         buffer[2000];
    /// the buffer length (must be retrieved by META_NVRAM_AudioBesLoudNess_Len)
    unsigned int bufferLength;
}Audio_Ex_SetACFToTarget_REQ_EX_T;

META_RESULT __stdcall META_Audio_EX_SetACFIIRToTargetEx(const unsigned int ms_timeout, const Audio_Ex_SetACFToTarget_REQ_EX_T *req);
META_RESULT __stdcall META_Audio_EX_SetACFIIRToTargetEx_r(const int meta_handle, const unsigned int ms_timeout, const Audio_Ex_SetACFToTarget_REQ_EX_T *req);

META_RESULT  __stdcall META_Audio_EX_SetACFilterCoefEx(unsigned int ms_timeout, const Audio_Ex_SetACFToTarget_REQ_EX_T *p_req);
META_RESULT  __stdcall META_Audio_EX_SetACFilterCoefEx_r(const int meta_handle, unsigned int ms_timeout, const Audio_Ex_SetACFToTarget_REQ_EX_T *p_req);

#define META_NVRAM_DESC_DEPTH    3
#define META_NVRAM_DESC_LENGTH   255
#define META_NVRAM_DESC_NUM      255

typedef struct
{
	unsigned int    u4ByteOffset;
	unsigned int    u4Length;  // unit: u1ElementSize, not bytes!
	unsigned char   u1ElementSize; // unit: bytes
	int             i4ElementNum; // element number
	unsigned char   u1ValidDepth;
	char            desc[META_NVRAM_DESC_DEPTH][META_NVRAM_DESC_LENGTH];
          
}meta_nvram_lid_desc_entry;

typedef struct
{
   int valid_num;
   int struct_size; 
   meta_nvram_lid_desc_entry list[META_NVRAM_DESC_NUM]; 	
}meta_nvram_lid_desc_t;

META_RESULT __stdcall META_NVRAM_AudioGainTableDescription(meta_nvram_lid_desc_t *pDescList);
META_RESULT  __stdcall META_NVRAM_AudioGainTable_Len(int *len);
/*
META_RESULT  __stdcall META_NVRAM_Compose_AudioGainTable(const nvram_audio_gain_table_struct *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioGainTable(nvram_audio_gain_table_struct *tbl, const char *buf, const int buf_len);
*/

//--------------------------------------------------------------------------//
//  BaseBand Testing                                                        //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  BaseBand Testing: data structure definition        //
//-----------------------------------------------------//
typedef struct
{
	unsigned int	addr;		// The address of register that is to be read.
} RegRead_Req;

typedef struct
{
	unsigned short	value;		// The read back value
	unsigned char	status;		// 0: success, others: read register fail.
} RegRead_Cnf;

typedef struct
{
	unsigned int	addr;		// The address of register that is to be written.
	unsigned short	value;		// The value that is to be written.
} RegWrite_Req;

typedef struct
{
	unsigned char	status;		// 0: success, others: write register fail.
} RegWrite_Cnf;

typedef struct
{
	unsigned char	channel;	// ADC channel number.
	unsigned short	Meacount;	// Number of measure times.
} ADCMeaData_Req;

typedef struct
{
	unsigned int	value;		// ADC value, it a sum value of each measurement data.
	unsigned char	status;		// 0: success, others: get ADC measurement fail.
} ADCMeaData_Cnf;

//-----------------------------------------------------//
//  BaseBand Testing: callback function definition     //
//-----------------------------------------------------//
typedef void (__stdcall *META_BB_READREG_CNF)(const RegRead_Cnf *result, const short token, void *usrData);
typedef void (__stdcall *META_BB_WRITEREG_CNF)(const RegWrite_Cnf *result, const short token, void *usrData);
typedef void (__stdcall *META_BB_ADCGETMEADATA_CNF)(const ADCMeaData_Cnf *result, const short token, void *usrData);

//-----------------------------------------------------//
//  BaseBand Testing: exported function definition     //
//-----------------------------------------------------//
META_RESULT  __stdcall META_BB_RegRead(const RegRead_Req *req, const META_BB_READREG_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_BB_RegRead_r(const int meta_handle, const RegRead_Req *req, const META_BB_READREG_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_BB_RegWrite(const RegWrite_Req *req, const META_BB_WRITEREG_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_BB_RegWrite_r(const int meta_handle, const RegWrite_Req *req, const META_BB_WRITEREG_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_PMIC_RegRead(unsigned int ms_timeout, const RegRead_Req *req, RegRead_Cnf *cnf);
META_RESULT  __stdcall META_PMIC_RegRead_r(const int meta_handle, unsigned int ms_timeout, const RegRead_Req *req, RegRead_Cnf *cnf);
META_RESULT  __stdcall META_PMIC_RegWrite(unsigned int ms_timeout, const RegWrite_Req *req, RegWrite_Cnf *cnf);
META_RESULT  __stdcall META_PMIC_RegWrite_r(const int meta_handle, unsigned int ms_timeout, const RegWrite_Req *req, RegWrite_Cnf *cnf);
META_RESULT  __stdcall META_BB_ADCGetMeaSumData(const ADCMeaData_Req *req, const META_BB_ADCGETMEADATA_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_BB_ADCGetMeaSumData_r(const int meta_handle, const ADCMeaData_Req *req, const META_BB_ADCGETMEADATA_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall META_BB_ADCGetMeaSumData_Ex(const unsigned int ms_timeout, const ADCMeaData_Req *req, ADCMeaData_Cnf *cnf);
META_RESULT  __stdcall META_BB_ADCGetMeaSumData_Ex_r(const int meta_handle, const unsigned int ms_timeout, const ADCMeaData_Req *req, ADCMeaData_Cnf *cnf);

//--------------------------------------------------------------------------//
//  FAT Access                                                              //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  FAT Access: data structure definition              //
//-----------------------------------------------------//
typedef enum {
	FAT_OPEN_READ = 0,
	FAT_OPEN_WRITE
}FAT_OPEN_MODE;

typedef enum {
	FAT_FIND_FILE = 0,
	FAT_FIND_FILE_RECURSIVE,
	FAT_FIND_DIR_RECURSIVE
}FAT_FIND_MODE;

typedef enum {
	FAT12 = 0,
	FAT16,
	FAT32
}FAT_TYPE;

typedef struct {
	FAT_TYPE		Type;
	unsigned int 	SectorsPerCluster;
	unsigned int	TotalSize;
	unsigned int	FreeSpace;
}FAT_DiskInfo_T;

typedef struct 
{
	char m_cDriveLetter;   // Target FAT disk drive letter such as: 'C'
	char *m_pcfilepath;    // File path of the file we intend to write into target FAT

}FAT_FILE_INFO_REQ_T;

//-----------------------------------------------------//
//  FAT Access: callback function definition           //
//-----------------------------------------------------//
typedef int (__stdcall *CALLBACK_META_FAT_PROGRESS)(unsigned char percent, int sent_bytes, int total_bytes, const short token, void *usr_arg);

//-----------------------------------------------------//
//  FAT Access: exported function definition           //
//-----------------------------------------------------//
META_RESULT  __stdcall META_FAT_Open(const char *fat_filepath, FAT_OPEN_MODE  mode, int *fs_handle, short *p_token);
META_RESULT  __stdcall META_FAT_Open_r(const int meta_handle, const char *fat_filepath, FAT_OPEN_MODE  mode, int *fs_handle, short *p_token);
META_RESULT  __stdcall META_FAT_Close(int *fs_handle, short *p_token);
META_RESULT  __stdcall META_FAT_Close_r(const int meta_handle, int *fs_handle, short *p_token);
META_RESULT  __stdcall META_FAT_GetFileSize(const int fs_handle, int *filesize, short *p_token);
META_RESULT  __stdcall META_FAT_GetFileSize_r(const int meta_handle, const int fs_handle, int *filesize, short *p_token);
META_RESULT  __stdcall META_FAT_Read(const int fs_handle, char *buf, const int buf_len, CALLBACK_META_FAT_PROGRESS  cb_progress, void  *cb_progress_arg, short *p_token);
META_RESULT  __stdcall META_FAT_Read_r(const int meta_handle, const int fs_handle, char *buf, const int buf_len, CALLBACK_META_FAT_PROGRESS  cb_progress, void  *cb_progress_arg, short *p_token);
META_RESULT  __stdcall META_FAT_Write(const int fs_handle, const char *buf, const int buf_len, CALLBACK_META_FAT_PROGRESS  cb_progress, void  *cb_progress_arg, short *p_token);
META_RESULT  __stdcall META_FAT_Write_r(const int meta_handle, const int fs_handle, const char *buf, const int buf_len, CALLBACK_META_FAT_PROGRESS  cb_progress, void  *cb_progress_arg, short *p_token);
META_RESULT  __stdcall META_FAT_Read_To_File(const int fs_handle, const char *local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void  *cb_progress_arg, short *p_token);
META_RESULT  __stdcall META_FAT_Read_To_File_r(const int meta_handle, const int fs_handle, const char *local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void  *cb_progress_arg, short *p_token);
META_RESULT  __stdcall META_FAT_Write_By_File(const int fs_handle, const char *local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void  *cb_progress_arg, short *p_token);
META_RESULT  __stdcall META_FAT_Write_By_File_r(const int meta_handle, const int fs_handle, const char *local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void  *cb_progress_arg, short *p_token);
META_RESULT  __stdcall META_FAT_Delete(const char *fat_filepath, short *p_token);
META_RESULT  __stdcall META_FAT_Delete_r(const int meta_handle, const char *fat_filepath, short *p_token);
META_RESULT  __stdcall META_FAT_Move(const char *fat_filepath, const char *new_fat_filepath, short *p_token);
META_RESULT  __stdcall META_FAT_Move_r(const int meta_handle, const char *fat_filepath, const char *new_fat_filepath, short *p_token);
META_RESULT  __stdcall META_FAT_Find_Start(const char *fat_base_dir, const char *fat_find_pattern, FAT_FIND_MODE	 find_mode, int *p_find_handle, short *p_token);
META_RESULT  __stdcall META_FAT_Find_Start_r(const int meta_handle, const char *fat_base_dir, const char *fat_find_pattern, FAT_FIND_MODE	 find_mode, int *p_find_handle, short *p_token);
META_RESULT  __stdcall META_FAT_Find_Head(int find_handle);
META_RESULT  __stdcall META_FAT_Find_Prev(int find_handle);
META_RESULT  __stdcall META_FAT_Find_Next(int find_handle);
META_RESULT  __stdcall META_FAT_Find_GetFileInfo(int find_handle, char *p_filepath, const int filepath_len, int *p_filesize);
META_RESULT  __stdcall META_FAT_Find_Close(int *p_find_handle);
META_RESULT  __stdcall META_FAT_GetDiskInfo(const char DriveLetter, FAT_DiskInfo_T  *p_DiskInfo, short *p_token);
META_RESULT  __stdcall META_FAT_GetDiskInfo_r(const int meta_handle, const char DriveLetter, FAT_DiskInfo_T  *p_DiskInfo, short *p_token);
META_RESULT  __stdcall META_FAT_RemoveDir(const char *fat_dirpath);
META_RESULT  __stdcall META_FAT_RemoveDir_r(const int meta_handle, const char *fat_dirpath);

META_RESULT __stdcall META_FAT_CheckEnoughSpace(FAT_FILE_INFO_REQ_T *req);
META_RESULT __stdcall META_FAT_CheckEnoughSpace_r(const int meta_handle, FAT_FILE_INFO_REQ_T *req);

META_RESULT  __stdcall META_FAT_Read_To_File_Ex(const int fs_handle, const char *filepath, 
												CALLBACK_META_FAT_PROGRESS  cb_progress, 
												void  *cb_progress_arg, short *p_token,
												int   *p_stopflag) ;

META_RESULT  __stdcall META_FAT_Read_To_File_Ex_r(const int meta_handle, const int fs_handle, 
												  const char *filepath, 
												  CALLBACK_META_FAT_PROGRESS  cb_progress, 
												  void  *cb_progress_arg, short *p_token,
												  int   *p_stopflag);

META_RESULT  __stdcall META_FAT_Write_By_File_Ex(const int fs_handle, 
												 const char *filepath, 
												 CALLBACK_META_FAT_PROGRESS  cb_progress, 
												 void  *cb_progress_arg, 
												 short *p_token,
												 int *p_stopfalg);

META_RESULT  __stdcall META_FAT_Write_By_File_Ex_r(const int meta_handle, 
												   const int fs_handle, 
												   const char *filepath, 
												   CALLBACK_META_FAT_PROGRESS  cb_progress, 
												   void  *cb_progress_arg, 
												   short *p_token,
												   int *p_stopflag);




/*  NOR_DRIVE = 1,
	NAND_DRIVE=2,
	CARD_DRIVE = 3,
	EXTERNAL_DRIVE = 4
*/
META_RESULT  __stdcall META_FAT_GetDriveType(unsigned int ms_timeout, const char DriveLetter, int *p_DriveType);
META_RESULT  __stdcall META_FAT_GetDriveType_r(const int meta_handle, unsigned int ms_timeout, const char DriveLetter, int *p_DriveType);
META_RESULT  __stdcall META_Check_ULC_support(unsigned int ms_timeout);
META_RESULT  __stdcall META_Check_ULC_support_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_Check_SmartPhoneModem_support(unsigned int ms_timeout);
META_RESULT  __stdcall META_Check_SmartPhoneModem_support_r(const int meta_handle, unsigned int ms_timeout);


typedef enum
{
	META_VERSION_USER_DEFINE
   ,META_VERSION_META_DLL_UTIL_VER
   ,VER_TYPE_END
    
}META_VERSION_TYPE;

typedef struct
{   
	
	META_VERSION_TYPE   m_eVerType;

//	bool                b_AssertWhenVerCheckFail;  // will cause assert when version check fail

	unsigned int        m_u4MainVersion;  // valid when m_eVerType = META_VERSION_USER_DEFINE
	unsigned int        m_u4MinorVersion; // valid when m_eVerType = META_VERSION_USER_DEFINE
	unsigned int        m_u4BuildNum;     // valid when m_eVerType = META_VERSION_USER_DEFINE
	

}META_UTIL_CHECK_TARGET_VER_REQ_T;

typedef struct
{ 
	bool         m_bCheckPass;
	unsigned int m_u4TargetMainVersion;  
	unsigned int m_u4TargetMinorVersion;
	unsigned int m_u4TargetBuildNum;   
}META_UTIL_CHECK_TARGET_VER_CNF_T;

typedef struct
{
	bool  b_TargetAssertCheckFlag;
	bool  b_SetCurRecvMsgTimes;
	unsigned char m_u1CurRecvMsgTimes;  // valid when b_SetCurRecvMsgTimes = true
}META_UTIL_SET_ASSERT_CHECK_PARAs_REQ_T;


META_RESULT  __stdcall META_Util_CheckTargetRequiredVersion(unsigned int ms_timeout, const META_UTIL_CHECK_TARGET_VER_REQ_T *req, META_UTIL_CHECK_TARGET_VER_CNF_T *cnf );
META_RESULT  __stdcall META_Util_CheckTargetRequiredVersion_r(const int meta_handle, unsigned int ms_timeout, const META_UTIL_CHECK_TARGET_VER_REQ_T *req, META_UTIL_CHECK_TARGET_VER_CNF_T *cnf );
META_RESULT  __stdcall META_Util_SetTargetAssertCheckParas(unsigned int ms_timeout, const META_UTIL_SET_ASSERT_CHECK_PARAs_REQ_T *req);
META_RESULT  __stdcall META_Util_SetTargetAssertCheckParas_r(const int meta_handle, unsigned int ms_timeout, const META_UTIL_SET_ASSERT_CHECK_PARAs_REQ_T *req);


META_RESULT  __stdcall META_Util_CheckIfTargetNVSecOn(unsigned int ms_timeout, bool *bOn);
META_RESULT  __stdcall META_Util_CheckIfTargetNVSecOn_r(const int meta_handle, unsigned int ms_timeout, bool *bOn);

META_RESULT __stdcall META_Util_RebootToNormalMode(unsigned int ms_timeout, unsigned short timeout);
META_RESULT __stdcall META_Util_RebootToNormalMode_r(const int meta_handle, unsigned int ms_timeout, unsigned short timeout);

META_RESULT __stdcall META_Util_QueryBTWiFiSingleAntennaCap(unsigned int ms_timeout, bool *bOn);
META_RESULT __stdcall META_Util_QueryBTWiFiSingleAntennaCap_r(const int meta_handle, unsigned int ms_timeout, bool *bOn);

META_RESULT __stdcall META_Util_SetAntennaPathToBT(const unsigned int ms_timeout);
META_RESULT __stdcall META_Util_SetAntennaPathToBT_r(const int meta_handle, const unsigned int ms_timeout);

META_RESULT __stdcall META_Util_SetAntennaPathToWiFi(const unsigned int ms_timeout);
META_RESULT __stdcall META_Util_SetAntennaPathToWiFi_r(const int meta_handle, const unsigned int ms_timeout);

#define META_LIPTON_OPTION_ON   0x00000001
#define META_TC01_OPTION_ON     0x00000002
#define META_AST_TD_OPTION_ON   0x00000004

META_RESULT __stdcall META_Util_QueryTargetOptionInfo(const unsigned int ms_timeout, unsigned int *info);
META_RESULT __stdcall META_Util_QueryTargetOptionInfo_r(const int meta_handle, const unsigned int ms_timeout,unsigned int *info);

META_RESULT __stdcall META_Util_QueryTargetLimitedStateIndicator(const unsigned int ms_timeout, unsigned int *info);
META_RESULT __stdcall META_Util_QueryTargetLimitedStateIndicator_r(const int meta_handle, const unsigned int ms_timeout,unsigned int *info);
//--------------------------------------------------------------------------//
//  WiFi Calibration                                                        //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  WiFi Calibration: data structure definition        //
//-----------------------------------------------------//

// WiFi Baseband Chip ID 
#define WIFI_BB_MT5911		0x00000001
#define WIFI_BB_MT5921		0x00000002

// WiFi RF Chip ID 
#define WIFI_RF_AL2236		0x00000001
#define WIFI_RF_MAX2827		0x00000002
#define WIFI_RF_MT5921      0x00000003

typedef enum {
	WIFI_TEST_RATE_1M = 0,     /* 1M          */
	WIFI_TEST_RATE_2M,         /* 2M          */
	WIFI_TEST_RATE_5_5M,       /* 5.5M        */
	WIFI_TEST_RATE_11M,        /* 11M         */
	WIFI_TEST_RATE_6M,         /* 6M          */
	WIFI_TEST_RATE_9M,         /* 9M          */
	WIFI_TEST_RATE_12M,        /* 12M         */
	WIFI_TEST_RATE_18M,        /* 18M         */
	WIFI_TEST_RATE_24M,        /* 24M         */
	WIFI_TEST_RATE_36M,        /* 36M         */
	WIFI_TEST_RATE_48M,        /* 48M         */
	WIFI_TEST_RATE_54M,        /* 54M         */
	WIFI_TEST_RATE_COUNT       /* Total count */
} WiFi_TestRate_E;

typedef enum {
	 WNDRV_HOST_INTERFACE_SDIO = 0
	,WNDRV_HOST_INTERFACE_HPI
	,WNDRV_HOST_INTERFACE_SPI
	,WNDRV_HOST_INTERFACE_CF_MEM
	,WNDRV_HOST_INTERFACE_CF_IO  
} WiFi_HostInterface_E;

typedef enum {
	WIFI_TX_ALL_ZEROS,
	WIFI_TX_ALL_ONES,
	WIFI_TX_ALTERNATE_BITS,
	WIFI_TX_PSEUDO_RANDOM
} WiFi_TestPktTxPattern_E;

typedef enum {
	WIFI_POWER_MODE_NORMAL,
	WIFI_POWER_MODE_IDLE,
	WIFI_POWER_MODE_SLEEP
} WiFi_PowerManagementMode_E;

typedef enum {    
	WIFI_RF_RX_TEST_MODE = 1  /* For RF Test use */
} WiFi_TestPktRxMode_E;

typedef enum {
	WIFI_RX_ANT_DIVERSITY_AGC,  /* AGC based selection */
	WIFI_RX_ANT_DIVERSITY_MPDU, /* MPDU based selection */
	WIFI_RX_ANT_FIXED_0,        /* Always 0 */ 
	WIFI_RX_ANT_FIXED_1         /* Always 1 */
} WiFi_RxAntSel_E;

typedef struct {
	unsigned int	bb_chip_id;
	char			bb_chip_ver[32];
	unsigned int	rf_chip_id;
	char			rf_chip_ver[32];
	unsigned char	support_802_11b;
	unsigned char	support_802_11a;
	unsigned char	support_802_11g;
	bool			eeprom_exist;
	unsigned int	eeprom_size;
	WiFi_HostInterface_E	host_interface;
} WiFi_ChipCapability_S;

typedef struct {
	unsigned int		ch_freq; /* Frq, units are kHz */
	WiFi_TestRate_E		tx_rate;
	int					dbm;
} WiFi_DBM2DAC_Set_S;

typedef struct {
	unsigned short		tx_gain_dac;
} WiFi_DBM2DAC_Query_S;

typedef struct {
	unsigned int		ch_freq;/* Frq, units are kHz */
	WiFi_TestRate_E		tx_rate;
	unsigned char		txAnt; /* 0 for Antenna 0; 1 for Antenna 1 */
	unsigned short		tx_gain_dac;
} WiFi_TestTx_S;

typedef struct {
	unsigned int			ch_freq;			/* Frq, units are kHz */
	WiFi_TestRate_E			tx_rate;
	unsigned short			tx_gain_dac;
	unsigned int			pktCount;
	unsigned int			pktInterval;		/* interval between each Tx Packet */
	unsigned int			pktLength;			/* 24~1500 */
	WiFi_TestPktTxPattern_E	pattern;			/* content of the Tx Packet */
	unsigned char			txAnt;				/* 0 for Antenna 0; 1 for Antenna 1 */
	unsigned char			is_short_preamble;	/* 0 for long preamble and 1 for short preamble */
	unsigned char			mac_header[ 24 ];	/* Frame Ctrl, Duration = 2bytes + 2bytes */
												/* Address 1 = 6 bytes */ 
												/* Address 2 = 6 bytes */ 
												/* Address 3 = 6 bytes */ 
												/* Sequence Ctrl = 2 bytes */
} WiFi_TestPktTx_S;

typedef struct {
	unsigned int			ch_freq;			/* Frq, units are kHz */
	WiFi_TestRate_E			tx_rate;
	unsigned short			tx_gain_dac;
	unsigned int			pktCount;
	unsigned int			pktInterval;		/* interval between each Tx Packet */
	unsigned int			pktLength;			/* 24~1500 */
	WiFi_TestPktTxPattern_E	pattern;			/* content of the Tx Packet */
	unsigned char			txAnt;				/* 0 for Antenna 0; 1 for Antenna 1 */
	unsigned int			txFlags;
	unsigned int			targetAlc;
	unsigned char			is_short_preamble;	/* 0 for long preamble and 1 for short preamble */
	unsigned char			mac_header[ 24 ];	/* Frame Ctrl, Duration = 2bytes + 2bytes */
												/* Address 1 = 6 bytes */ 
												/* Address 2 = 6 bytes */ 
												/* Address 3 = 6 bytes */ 
												/* Sequence Ctrl = 2 bytes */
} WiFi_TestPktTx_Ex_S;

typedef struct {    
	unsigned int		pkt_sent_count;  /* total num sent */
	unsigned int		pkt_sent_acked;  /* acked num */    
} WiFi_TxStatus_S;


typedef struct {    
	unsigned int		pkt_sent_count;  /* total num sent */
	unsigned int		pkt_sent_acked;  /* acked num */    
	unsigned short		avgAlc;
	unsigned char		cckGainControl;
    unsigned char		ofdmGainControl;
} WiFi_TxStatus_Ex_S;

typedef struct {
	unsigned int				ch_freq;  /* Frq, units are kHz */
	WiFi_TestPktRxMode_E		mode;
	WiFi_RxAntSel_E				rxAnt;
} WiFi_TestPktRx_S;

typedef struct {    
	unsigned int		int_rx_ok_num;     /* number of packets that Rx ok from interrupt */
	unsigned int		int_crc_err_num;   /* number of packets that CRC error from interrupt */
	unsigned int		pau_rx_pkt_count;  /* number of packets that Rx ok from PAU */
	unsigned int		pau_crc_err_count; /* number of packets that CRC error from PAU */
	unsigned int		pau_cca_count;     /* CCA rising edge count */
	unsigned int		pau_rx_fifo_full_count; /* number of lost packets due to FiFo full */
	unsigned int		int_long_preamble_num;
	unsigned int		int_short_preamble_num;
	unsigned int		int_rate_ok_num[ WIFI_TEST_RATE_COUNT ];
	unsigned int		int_rate_crc_err_num[ WIFI_TEST_RATE_COUNT ];
	int					int_rssi_max;
	int					int_rssi_min;
	int					int_rssi_mean;
	int					int_rssi_variance;
} WiFi_RxStatus_S;

typedef struct {    
	int  ED;
	int  OSD;
	int  SQ1;
	int  SFD;
	int  CRC16;
} WiFi_RxCounter_S;

typedef struct {    
	unsigned int	channel_num;
	unsigned char	channel_list[64];
} WiFi_ChannelList_S;

typedef struct {    
	unsigned char	country_code[2];
} WiFi_RegDomain_S;

typedef struct {
	unsigned int	index;		// 32bits alignment index, +4 
	unsigned int	mcr_data32;
} WiFi_MACReg32_S;

typedef struct {
	unsigned int	index;		// 16bits alignment index, +2 
	unsigned short	mcr_data16;
} WiFi_MACReg16_S;

typedef struct {
	unsigned int	index;		// 8bits alignment index, +1 
	unsigned char	bbcr_data8;
} WiFi_BBReg8_S;

typedef struct {
	unsigned int	index;		// 16bits alignment index, +2 
	unsigned short	eeprom_data16;
} WiFi_EEPROM_S;

//-----------------------------------------------------//
//  WiFi Calibration: WNDRV SET Functions              //
//-----------------------------------------------------//
META_RESULT  __stdcall META_WiFi_Stop(unsigned int  ms_timeout);
META_RESULT  __stdcall META_WiFi_Stop_r(const int meta_handle, unsigned int  ms_timeout);
META_RESULT  __stdcall META_WiFi_ContTx(unsigned int  ms_timeout, const WiFi_TestTx_S *req);
META_RESULT  __stdcall META_WiFi_ContTx_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TestTx_S *req);
META_RESULT  __stdcall META_WiFi_LocalFrequencyMeasure(unsigned int  ms_timeout, const WiFi_TestTx_S *req);
META_RESULT  __stdcall META_WiFi_LocalFrequencyMeasure_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TestTx_S *req);
META_RESULT  __stdcall META_WiFi_CarrierSuppressionMeasure(unsigned int  ms_timeout, const WiFi_TestTx_S *req);
META_RESULT  __stdcall META_WiFi_CarrierSuppressionMeasure_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TestTx_S *req);
META_RESULT  __stdcall META_WiFi_ContPktTx(unsigned int  ms_timeout, const WiFi_TestPktTx_S *req);
META_RESULT  __stdcall META_WiFi_ContPktTx_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TestPktTx_S *req);
META_RESULT  __stdcall META_WiFi_ContPktTx_Ex(unsigned int  ms_timeout, const WiFi_TestPktTx_Ex_S *req);
META_RESULT  __stdcall META_WiFi_ContPktTx_Ex_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TestPktTx_Ex_S *req);


META_RESULT  __stdcall META_WiFi_SetPowerManagementMode(unsigned int  ms_timeout, const WiFi_PowerManagementMode_E  mode);
META_RESULT  __stdcall META_WiFi_SetPowerManagementMode_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_PowerManagementMode_E  mode);
META_RESULT  __stdcall META_WiFi_ContPktRx(unsigned int  ms_timeout, const WiFi_TestPktRx_S *req);
META_RESULT  __stdcall META_WiFi_ContPktRx_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TestPktRx_S *req);
META_RESULT  __stdcall META_WiFi_SetRegDomain(unsigned int  ms_timeout, const WiFi_RegDomain_S  *req);
META_RESULT  __stdcall META_WiFi_SetRegDomain_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_RegDomain_S  *req);
META_RESULT  __stdcall META_WiFi_SetDbmToDac(unsigned int  ms_timeout, const WiFi_DBM2DAC_Set_S *req);
META_RESULT  __stdcall META_WiFi_SetDbmToDac_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_DBM2DAC_Set_S *req);
META_RESULT  __stdcall META_WiFi_MACReg32Write(unsigned int  ms_timeout, const WiFi_MACReg32_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_MACReg32Write_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_MACReg32_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_MACReg16Write(unsigned int  ms_timeout, const WiFi_MACReg16_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_MACReg16Write_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_MACReg16_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_BBRegWrite(unsigned int  ms_timeout, const WiFi_BBReg8_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_BBRegWrite_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_BBReg8_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_EEPROM_Write(unsigned int  ms_timeout, const WiFi_EEPROM_S *array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_EEPROM_Write_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_EEPROM_S *array, unsigned int array_cnt);

//-----------------------------------------------------//
//  WiFi Calibration: WNDRV QUERY Functions            //
//-----------------------------------------------------//
META_RESULT  __stdcall META_WiFi_QueryTxStatus(unsigned int  ms_timeout, WiFi_TxStatus_S *cnf);
META_RESULT  __stdcall META_WiFi_QueryTxStatus_r(const int meta_handle, unsigned int  ms_timeout, WiFi_TxStatus_S *cnf);
META_RESULT  __stdcall META_WiFi_QueryTxStatus_Ex(unsigned int  ms_timeout, WiFi_TxStatus_Ex_S *cnf);
META_RESULT  __stdcall META_WiFi_QueryTxStatus_Ex_r(const int meta_handle, unsigned int  ms_timeout, WiFi_TxStatus_Ex_S *cnf);
META_RESULT  __stdcall META_WiFi_QueryRxStatus(unsigned int  ms_timeout, WiFi_RxStatus_S *cnf);
META_RESULT  __stdcall META_WiFi_QueryRxStatus_r(const int meta_handle, unsigned int  ms_timeout, WiFi_RxStatus_S *cnf);
META_RESULT  __stdcall META_WiFi_QueryChannelList(unsigned int  ms_timeout, WiFi_ChannelList_S *cnf);
META_RESULT  __stdcall META_WiFi_QueryChannelList_r(const int meta_handle, unsigned int  ms_timeout, WiFi_ChannelList_S *cnf);
META_RESULT  __stdcall META_WiFi_QueryRxCounter(unsigned int  ms_timeout, WiFi_RxCounter_S *cnf);
META_RESULT  __stdcall META_WiFi_QueryRxCounter_r(const int meta_handle, unsigned int  ms_timeout, WiFi_RxCounter_S *cnf);
META_RESULT  __stdcall META_WiFi_QueryDbmToDac(unsigned int  ms_timeout, WiFi_DBM2DAC_Query_S  *cnf);
META_RESULT  __stdcall META_WiFi_QueryDbmToDac_r(const int meta_handle, unsigned int  ms_timeout, WiFi_DBM2DAC_Query_S  *cnf);
META_RESULT  __stdcall META_WiFi_MACReg32Read(unsigned int  ms_timeout, WiFi_MACReg32_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_MACReg32Read_r(const int meta_handle, unsigned int  ms_timeout, WiFi_MACReg32_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_MACReg16Read(unsigned int  ms_timeout, WiFi_MACReg16_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_MACReg16Read_r(const int meta_handle, unsigned int  ms_timeout, WiFi_MACReg16_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_BBRegRead(unsigned int  ms_timeout, WiFi_BBReg8_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_BBRegRead_r(const int meta_handle, unsigned int  ms_timeout, WiFi_BBReg8_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_EEPROM_Read(unsigned int  ms_timeout, WiFi_EEPROM_S *array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_EEPROM_Read_r(const int meta_handle, unsigned int  ms_timeout, WiFi_EEPROM_S *array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_DacDcOffsetAutoCalibration(unsigned int  ms_timeout, WiFi_DAC_DC_Offset_S  *cnf);
META_RESULT  __stdcall META_WiFi_DacDcOffsetAutoCalibration_r(const int meta_handle, unsigned int  ms_timeout, WiFi_DAC_DC_Offset_S  *cnf);

//-----------------------------------------------------//
//  WiFi Calibration: Exported Functions               //
//-----------------------------------------------------//
META_RESULT  __stdcall META_WiFi_QueryChipCapability(unsigned int  ms_timeout, WiFi_ChipCapability_S  *cnf);
META_RESULT  __stdcall META_WiFi_QueryChipCapability_r(const int meta_handle, unsigned int  ms_timeout, WiFi_ChipCapability_S  *cnf);
META_RESULT  __stdcall META_WiFi_SetMacAddress(unsigned int  ms_timeout, const WiFi_MacAddress_S  *mac);
META_RESULT  __stdcall META_WiFi_SetMacAddress_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_MacAddress_S  *mac);
META_RESULT  __stdcall META_WiFi_SetTxPower2400M(unsigned int  ms_timeout, const WiFi_TxPower_2400M_S  *txpwr);
META_RESULT  __stdcall META_WiFi_SetTxPower2400M_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TxPower_2400M_S  *txpwr);
META_RESULT  __stdcall META_WiFi_SetTxPower5000M(unsigned int  ms_timeout, const WiFi_TxPower_5000M_S  *txpwr);
META_RESULT  __stdcall META_WiFi_SetTxPower5000M_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TxPower_5000M_S  *txpwr);
META_RESULT  __stdcall META_WiFi_SetDacDcOffset(unsigned int  ms_timeout, const WiFi_DAC_DC_Offset_S  *dac_dc_offset);
META_RESULT  __stdcall META_WiFi_SetDacDcOffset_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_DAC_DC_Offset_S  *dac_dc_offset);

META_RESULT  __stdcall META_WiFi_SetTxALC2400M(unsigned int  ms_timeout, const WiFi_TxALC_2400M_S  *txalc);
META_RESULT  __stdcall META_WiFi_SetTxALC2400M_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TxALC_2400M_S  *txalc);

//--------------------------------------------------------------------------//
//  BT Calibration                                                          //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  BT Calibration: data structure definition          //
//-----------------------------------------------------//

// BT Module ID 
#define BT_NOT_SUPPORT		0x00000000
#define BTMODULE_MT6601		0x00000011
#define BTMODULE_MT6611	    0x00000012
#define BTMODULE_MT6612     0x00000013
#define BTMODULE_MT6616     0x00000014
#define BTMODULE_MT6236     0x00000015
#define BTMODULE_MT6255     0x00000016
#define BTMODULE_MT6276     0x00000017
#define BTMODULE_RFMD3500   0x00000021 
#define BTMODULE_RFMD4020	0x00000022

//#define BT_PACKET_LEN       339
#define BT_PACKET_LEN       1021  // because BT2.0 support at most 1021 bytes per packet
typedef struct {
	unsigned char	id;
} BT_ModuleID_S;

typedef struct {
	unsigned char   m_event;
	char         	m_status;
	unsigned short  m_handle;
	unsigned char	m_len;
	unsigned char	m_parms[256];
} BT_HCI_EVENT;

typedef struct {
	unsigned short	m_opcode;
	unsigned char	m_len;
	unsigned char	m_cmd[256];
} BT_HCI_COMMAND;
typedef struct {
    unsigned short           m_con_hdl;
    unsigned short           m_len;      	
    unsigned char            m_buffer[BT_PACKET_LEN]; 
} BT_HCI_BUFFER;
typedef struct {
    unsigned short           m_len;
    unsigned char            m_data[BT_PACKET_LEN];
} BT_HCI_PACKET;
typedef struct {
    unsigned short           m_con_hdl;
    unsigned short           m_len;      	
    unsigned short           m_total_pks; 
} BT_HCI_TX_PURE_TEST;

typedef struct {
    unsigned int             m_used_time;
    unsigned short           m_len;     
} BT_HCI_TX_PURE_TEST_STAT;

typedef struct {
    unsigned int             m_used_time;
    unsigned short           m_len;     
} BT_HCI_RX_PURE_TEST_STAT;

typedef struct {
    unsigned int             m_u4UsedTime;
    unsigned short           m_u2PktSentNum; 
    
} BT_HCI_TX_PURE_TEST_STAT_V2;

//-----------------------------------------------------//
//  BT Calibration Functions                           //
//-----------------------------------------------------//
META_RESULT  __stdcall META_BT_QueryModuleID(unsigned int  ms_timeout, BT_ModuleID_S  *cnf);
META_RESULT  __stdcall META_BT_QueryModuleID_r(const int meta_handle, unsigned int  ms_timeout, BT_ModuleID_S  *cnf);

typedef void (__stdcall *META_BT_HCI_CNF)(const BT_HCI_EVENT *cnf, const short token, void *usrData);
typedef void (__stdcall *META_BT_HCI_TXDATA_CNF)(const BT_HCI_PACKET *cnf, const short token, void *usrData);
typedef void (__stdcall *META_BT_AUTO_HCI_CNF)(const BT_HCI_EVENT *cnf, const short token, void *usrData);
typedef void (__stdcall *META_BT_HCI_RXDATA_CNF)(const BT_HCI_BUFFER *cnf, const short token, void *usrData);

typedef void (__stdcall *META_BT_HCI_TXTEST_CNF)(const BT_HCI_TX_PURE_TEST_STAT *cnf, const short token, void *usrData);
typedef void (__stdcall *META_BT_HCI_RXTEST_CNF)(const BT_HCI_RX_PURE_TEST_STAT *cnf, const short token, void *usrData);

typedef void (__stdcall *META_BT_HCI_TXTEST_V2_CNF)(const BT_HCI_TX_PURE_TEST_STAT_V2 *cnf, const short token, void *usrData);

typedef struct{
	META_BT_HCI_TXDATA_CNF      m_SendDataCallback;
	META_BT_HCI_RXDATA_CNF		m_RecvDataCallback;
	META_BT_AUTO_HCI_CNF		m_AutoCallback;
	META_BT_HCI_TXTEST_CNF		m_TxTestCallback;
	META_BT_HCI_RXTEST_CNF		m_RxTestCallback;
	META_BT_HCI_TXTEST_V2_CNF   m_TxTestCallback_V2;
} BT_OtherCallBack;
META_RESULT  __stdcall META_BT_SendHCICommand(unsigned int  ms_timeout,BT_HCI_COMMAND *req, META_BT_HCI_CNF  cb, void  *cb_arg, unsigned char Cmpltcode);
META_RESULT  __stdcall META_BT_SendHCICommand_r(const int meta_handle, unsigned int  ms_timeout,BT_HCI_COMMAND *req, META_BT_HCI_CNF  cb, void  *cb_arg, unsigned char Cmpltcode);

META_RESULT  __stdcall META_BT_CancelHCICommand(unsigned int  ms_timeout);
META_RESULT  __stdcall META_BT_CancelHCICommand_r(const int meta_handle, unsigned int  ms_timeout);
META_RESULT  __stdcall META_BT_SendHCIData(unsigned int  ms_timeout,BT_HCI_BUFFER *snd, META_BT_HCI_TXDATA_CNF  cb_tx, void  *cb_arg);
META_RESULT  __stdcall META_BT_SendHCIData_r(const int meta_handle, unsigned int  ms_timeout,BT_HCI_BUFFER *snd, META_BT_HCI_TXDATA_CNF  cb_tx, void  *cb_arg);
META_RESULT  __stdcall META_BT_RegisterAutoCallback(META_BT_AUTO_HCI_CNF cb_auto);
META_RESULT  __stdcall META_BT_RegisterAutoCallback_r(const int meta_handle,META_BT_AUTO_HCI_CNF cb_auto);
META_RESULT  __stdcall META_BT_ReceiveHCIData(META_BT_HCI_RXDATA_CNF cb_rx);
META_RESULT  __stdcall META_BT_ReceiveHCIData_r(const int meta_handle,META_BT_HCI_RXDATA_CNF cb_rx);

META_RESULT  __stdcall META_BT_TxPureTest(unsigned int  ms_timeout, BT_HCI_TX_PURE_TEST *snd, META_BT_HCI_TXTEST_CNF cb_tx, void  *cb_arg);
META_RESULT  __stdcall META_BT_TxPureTest_r(const int meta_handle, unsigned int  ms_timeout, BT_HCI_TX_PURE_TEST *snd, META_BT_HCI_TXTEST_CNF cb_tx, void  *cb_arg);
META_RESULT  __stdcall META_BT_RxTestStart(unsigned int  ms_timeout, META_BT_HCI_RXTEST_CNF cb_rx);
META_RESULT  __stdcall META_BT_RxTestStart_r(const int meta_handle, unsigned int  ms_timeout, META_BT_HCI_RXTEST_CNF cb_rx);
META_RESULT  __stdcall META_BT_RxTestEnd(unsigned int  ms_timeout); 
META_RESULT  __stdcall META_BT_RxTestEnd_r(const int meta_handle, unsigned int  ms_timeout);

META_RESULT  __stdcall META_BT_TxPureTest_V2(unsigned int  ms_timeout, BT_HCI_TX_PURE_TEST *snd, META_BT_HCI_TXTEST_V2_CNF cb_txtest, void  *cb_arg);
META_RESULT  __stdcall META_BT_TxPureTest_V2_r(const int meta_handle, unsigned int  ms_timeout, BT_HCI_TX_PURE_TEST	*snd, META_BT_HCI_TXTEST_V2_CNF cb_txtest, void  *cb_arg);

META_RESULT  __stdcall META_BT_RxTestStart_V2(unsigned int  ms_timeout, META_BT_HCI_RXTEST_CNF cb_rx);
META_RESULT  __stdcall META_BT_RxTestStart_V2_r(const int meta_handle, unsigned int ms_timeout, META_BT_HCI_RXTEST_CNF cb_rx);

META_RESULT  __stdcall META_BT_EnableNvramOnlineUpdate(unsigned int  ms_timeout);
META_RESULT  __stdcall META_BT_EnableNvramOnlineUpdate_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_BT_DisableNvramOnlineUpdate(unsigned int  ms_timeout);
META_RESULT  __stdcall META_BT_DisableNvramOnlineUpdate_r(const int meta_handle, unsigned int ms_timeout);


META_RESULT  __stdcall META_BT_EnablePcmClockSyncSignal(unsigned int  ms_timeout);
META_RESULT  __stdcall META_BT_EnablePcmClockSyncSignal_r(const int meta_handle, unsigned int ms_timeout);

META_RESULT  __stdcall META_BT_DisablePcmClockSyncSignal(unsigned int  ms_timeout);
META_RESULT  __stdcall META_BT_DisablePcmClockSyncSignal_r(const int meta_handle, unsigned int ms_timeout);

META_RESULT  __stdcall META_BT_RemoveAutoCallback();
META_RESULT  __stdcall META_BT_RemoveAutoCallback_r(const int meta_handle);
META_RESULT  __stdcall META_BT_RemoveReceiveHCIDataCallback();
META_RESULT  __stdcall META_BT_RemoveReceiveHCIDataCallback_r(const int meta_handle);

META_RESULT __stdcall META_BT_POWERON_EX(const unsigned int ms_timeout, const unsigned char u1WaitFlag);
META_RESULT __stdcall META_BT_POWERON_EX_r(const int meta_handle, const unsigned int ms_timeout, const unsigned char u1WaitFlag);
META_RESULT __stdcall META_BT_POWEROFF_EX(const unsigned int ms_timeout, const unsigned char u1WaitFlag);
META_RESULT __stdcall META_BT_POWEROFF_EX_r(const int meta_handle, const unsigned int ms_timeout, const unsigned char u1WaitFlag);

//----------------------------------------------------------------//
//                              FM                                //
//----------------------------------------------------------------//

//--------------------------//
//    FM data structures    //
//--------------------------//
typedef enum
{
    FM_CHIP_ID_MT6189AN = 0,
    FM_CHIP_ID_MT6189BN_CN = 1,
    FM_CHIP_ID_MT6188A = 3,
    FM_CHIP_ID_MT6188C = 4,
    FM_CHIP_ID_MT6188D = 5,
    FM_CHIP_ID_MT6616 = 6
    ,FM_CHIP_ID_MT6276 = 7
    ,FM_CHIP_ID_MT6255 = 8
    ,FM_CHIP_ID_MT6251 = 9
}FM_CHIP_ID_E;

typedef struct
{
	unsigned char m_ucChipId;
}FM_CHIP_ID_CNF_T;

typedef struct
{
	short m_i2CurFreq;  // freq range is [875, 1080]
}FM_FREQ_REQ_T;



typedef struct
{
    unsigned char m_ucSignalLevel;
}FM_RSSI_CNF_T;

typedef struct
{
	//unsigned char m_ucIfCnt;
	unsigned short m_u2IfCnt;
	
}FM_IF_CNT_CNF_T;

typedef struct
{
	unsigned short m_u2MonoOrStereo;  // 0: mono, 1: stereo
	unsigned short m_u2SblendOnOrOff; // 0: sblend off, 1: sblend on
	unsigned int   m_u4ItemValue;  // 0: disable, 1: enable

}FM_MONO_STEREO_BLEND_REQ_T;

typedef struct  // freq range is [875, 1080]
{
   short m_i2StartFreq;    // note: when we try to search next: start freq should <= stop freq 
   short m_i2StopFreq;     // note: when we try to search prev: start freq should >= stop freq

}FM_FREQ_RANGE_REQ_T;

typedef struct
{
	unsigned char m_ucExit;      // 0: don't exist, 1: exist
	short         m_i2ValidFreq; // -1: settings error, 0: invalid freq, others: 875-1080 valid

}FM_VAILD_FREQ_CNF_T;

typedef struct
{
   unsigned int m_u4RssiThreshold;

}FM_RSSI_THRESHOLD_REQ_T;

typedef struct
{
   unsigned int m_u4IfCntDelta;

}FM_IF_CNT_DELTA_REQ_T;


typedef struct
{
	unsigned char m_ucAddr;
	
}FM_READ_BYTE_ADDR_REQ_T;


typedef struct
{
   unsigned short m_u2ReadByte;

}FM_READ_BYTE_CNF_T;


typedef struct
{
	unsigned char m_ucAddr;
	unsigned short m_u2WriteByte;
}FM_WRITE_BYTE_REQ_T;

typedef struct
{
    unsigned char m_bOnOff;  // 0: off, 1: on

}FM_SOFT_MUTE_ONOFF_REQ_T;

typedef struct
{
	unsigned char m_ucStage;  // 1~3
}FM_STAGE_REQ_T;

typedef struct
{
	unsigned char  m_ucHighOrLow;
}FM_HL_Side_CNF_T;

typedef struct
{
	unsigned char m_ucStereoOrMono;

}FM_Stereo_Mono_CNF_T;

// for MT6616 new API
typedef struct
{
    unsigned char m_ucVolume;
    char m_cDigitalGainIndex;
}FM_Volume_Setting_REQ_T;

typedef struct
{
    unsigned short m_u2Bitmap[16];
}FM_AutoScan_CNF_T;

typedef struct
{
    unsigned char m_ucRDSOn;
}FM_SetRDS_REQ_T;

typedef struct
{
    unsigned char m_ucRXFilterBW;
}FM_RX_FilterBW_CNF_T;

typedef struct
{
    unsigned char m_ucPAMDLevel;
}FM_PAMD_Level_CNF_T;

typedef struct
{
    unsigned char m_ucMR;
}FM_MR_CNF_T;

typedef struct
{
    unsigned int m_u4DecodeMode;
}FM_Decode_Mode_REQ_T;

typedef struct
{
    unsigned int m_u4HCC;
}FM_HCC_REQ_T;

typedef struct
{
    unsigned int m_u4PAMDThreshold;
}FM_PAMD_Threshold_REQ_T;

typedef struct
{
    unsigned int m_u4SoftmuteEnable;
}FM_Softmute_Enable_REQ_T;

typedef struct
{
    unsigned int m_u4DeemphasisLevel;
}FM_Deemphasis_Level_REQ_T;

typedef struct
{
	unsigned int m_u4HLSide;
}FM_HL_Side_REQ_T;

typedef struct
{
    unsigned int m_u4DemodBandwidth;
}FM_Demod_Bandwidth_REQ_T;

typedef struct
{
    unsigned int m_u4DynamicLimiter;
}FM_DynamicLimiter_REQ_T;

typedef struct
{
    unsigned int m_u4SoftmuteRate;
}FM_Softmute_Rate_REQ_T;

typedef enum
{
    RDS_CMD_NONE = 0,   // No command. This is usually an error.
    RDS_CMD_PI_CODE,
    RDS_CMD_PTY_CODE,
    RDS_CMD_PROGRAMNAME,
    RDS_CMD_LOCDATETIME,
    RDS_CMD_UTCDATETIME,
    RDS_CMD_LAST_RADIOTEXT,
    RDS_CMD_AF,
    RDS_CMD_AF_LIST,  
    RDS_CMD_AFON,
    RDS_CMD_TAON,
    RDS_CMD_TAON_OFF
}RdsCmd;

typedef enum
{
    RDS_FLAG_IS_TP              	              = 0x0001, // Program is a traffic program
    RDS_FLAG_IS_TA                            = 0x0002, // Program currently broadcasts a traffic ann.
    RDS_FLAG_IS_MUSIC                     = 0x0004, // Program currently broadcasts music
    RDS_FLAG_IS_STEREO                  = 0x0008, // Program is transmitted in stereo
    RDS_FLAG_IS_ARTIFICIAL_HEAD = 0x0010, // Program is an artificial head recording
    RDS_FLAG_IS_COMPRESSED       = 0x0020, // Program content is compressed
    RDS_FLAG_IS_DYNAMIC_PTY       = 0x0040, // Program type can change 
    RDS_FLAG_TEXT_AB                      = 0x0080  // If this flag changes state, a new radio text 					 string begins
}RdsFlag;

typedef enum {
   RDS_EVENT_FLAGS          = 0x0001, // One of the RDS flags has changed state
   RDS_EVENT_PI_CODE        = 0x0002, // The program identification code has changed
   RDS_EVENT_PTY_CODE       = 0x0004, // The program type code has changed
   RDS_EVENT_PROGRAMNAME    = 0x0008, // The program name has changed
   RDS_EVENT_UTCDATETIME    = 0x0010, // A new UTC date/time is available
   RDS_EVENT_LOCDATETIME    = 0x0020, // A new local date/time is available
   RDS_EVENT_LAST_RADIOTEXT = 0x0040, // A radio text string was completed
   RDS_EVENT_AF                   = 0x0080, // Current Channel RF signal strength too weak, need do AF switch  
   RDS_EVENT_AF_LIST        = 0x0100, // An alternative frequency list is ready
   RDS_EVENT_AFON_LIST        = 0x0200, // An alternative frequency list is ready
   RDS_EVENT_TAON        = 0x0400,  // Other Network traffic announcement start
   RDS_EVENT_TAON_OFF        = 0x0800 // Other Network traffic announcement finished.
} RdsEvent;

typedef struct
{
    RdsCmd m_eCmd;
}FM_RDS_Info_REQ_T;

typedef struct
{
    unsigned short m_buffer[64];
}FM_RDS_Info_CNF_T;

typedef struct
{
    RdsFlag m_eFlag;
    unsigned short m_buffer[64];
}FM_RDS_Status_CNF_T;

typedef struct
{
    unsigned short m_u2GoodBlock;
}FM_RDS_Good_Block_Counter_CNF_T;

typedef struct
{
    unsigned short m_u2BadBlock;
}FM_RDS_Bad_Block_Counter_CNF_T;

typedef struct
{
    unsigned short m_u2GroupCounter[32];
}FM_RDS_Group_Counter_CNF_T;

typedef struct
{
    short m_i2StartFreq;
    unsigned char m_ucDirection;
}FM_HWSeek_REQ_T;

typedef struct
{
    short m_i2EndFreq;
}FM_HWSeek_CNF_T;


typedef struct
{
    unsigned short m_u2StereoBlendControl;
}FM_SetStereoBlend_REQ_T;

typedef struct
{
    unsigned short m_u2Blocks[5];
}FM_RDS_Block_CNF_T;

//--------------------------//
//      FM Functions        //
//--------------------------//
META_RESULT  __stdcall META_FM_GetChipId(unsigned int ms_timeout, FM_CHIP_ID_CNF_T *cnf);
META_RESULT  __stdcall META_FM_GetChipId_r(const int meta_handle, unsigned int ms_timeout, FM_CHIP_ID_CNF_T *cnf);

META_RESULT  __stdcall META_FM_PowerOn(unsigned int ms_timeout);
META_RESULT  __stdcall META_FM_PowerOn_r(const int meta_handle, unsigned int ms_timeout);

META_RESULT  __stdcall META_FM_PowerOff(unsigned int ms_timeout);
META_RESULT  __stdcall META_FM_PowerOff_r(const int meta_handle, unsigned int ms_timeout);

META_RESULT  __stdcall META_FM_SetFreq(unsigned int ms_timeout, FM_FREQ_REQ_T *req);
META_RESULT  __stdcall META_FM_SetFreq_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_REQ_T *req);

META_RESULT  __stdcall META_FM_GetRSSI(unsigned int ms_timeout, FM_FREQ_REQ_T *req, FM_RSSI_CNF_T *cnf);
META_RESULT  __stdcall META_FM_GetRSSI_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_REQ_T *req, FM_RSSI_CNF_T *cnf);

META_RESULT  __stdcall META_FM_GetIfCnt(unsigned int ms_timeout, FM_FREQ_REQ_T *req, FM_IF_CNT_CNF_T *cnf);
META_RESULT  __stdcall META_FM_GetIfCnt_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_REQ_T *req, FM_IF_CNT_CNF_T *cnf);

META_RESULT __stdcall META_FM_SearchNextFreq(unsigned int ms_timeout, FM_FREQ_RANGE_REQ_T *req, FM_VAILD_FREQ_CNF_T *cnf);
META_RESULT __stdcall META_FM_SearchNextFreq_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_RANGE_REQ_T *req, FM_VAILD_FREQ_CNF_T *cnf);

META_RESULT __stdcall META_FM_SearchPrevFreq(unsigned int ms_timeout, FM_FREQ_RANGE_REQ_T *req, FM_VAILD_FREQ_CNF_T *cnf);
META_RESULT __stdcall META_FM_SearchPrevFreq_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_RANGE_REQ_T *req, FM_VAILD_FREQ_CNF_T *cnf);

META_RESULT  __stdcall META_FM_SetMonoOrStereo_Blend(unsigned int ms_timeout, FM_MONO_STEREO_BLEND_REQ_T *req);
META_RESULT  __stdcall META_FM_SetMonoOrStereo_Blend_r(const int meta_handle, unsigned int ms_timeout, FM_MONO_STEREO_BLEND_REQ_T *req);

META_RESULT  __stdcall META_FM_SetRssiThreold(unsigned int ms_timeout, FM_RSSI_THRESHOLD_REQ_T *req);
META_RESULT  __stdcall META_FM_SetRssiThreold_r(const int meta_handle, unsigned int ms_timeout, FM_RSSI_THRESHOLD_REQ_T *req);

META_RESULT  __stdcall META_FM_SetIfCntDelta(unsigned int ms_timeout, FM_IF_CNT_DELTA_REQ_T *req);
META_RESULT  __stdcall META_FM_SetIfCntDelta_r(const int meta_handle, unsigned int ms_timeout, FM_IF_CNT_DELTA_REQ_T *req);

META_RESULT __stdcall META_FM_ReadByte(unsigned int ms_timeout, FM_READ_BYTE_ADDR_REQ_T *req, FM_READ_BYTE_CNF_T *cnf);
META_RESULT __stdcall META_FM_ReadByte_r(const int meta_handle, unsigned int ms_timeout, FM_READ_BYTE_ADDR_REQ_T *req, FM_READ_BYTE_CNF_T *cnf);

META_RESULT  __stdcall META_FM_WriteByte(unsigned int ms_timeout, FM_WRITE_BYTE_REQ_T *req);
META_RESULT  __stdcall META_FM_WriteByte_r(const int meta_handle, unsigned int ms_timeout, FM_WRITE_BYTE_REQ_T *req);

META_RESULT  __stdcall META_FM_SetSoftMute(unsigned int ms_timeout, FM_SOFT_MUTE_ONOFF_REQ_T *req);
META_RESULT  __stdcall META_FM_SetSoftMute_r(const int meta_handle, unsigned int ms_timeout, FM_SOFT_MUTE_ONOFF_REQ_T *req);

META_RESULT  __stdcall META_FM_SelectSoftMuteStage(unsigned int ms_timeout, FM_STAGE_REQ_T *req);
META_RESULT  __stdcall META_FM_SelectSoftMuteStage_r(const int meta_handle, unsigned int ms_timeout, FM_STAGE_REQ_T *req); 

META_RESULT  __stdcall META_FM_SelectSBlendStage(unsigned int ms_timeout, FM_STAGE_REQ_T *req);
META_RESULT  __stdcall META_FM_SelectSBlendStage_r(const int meta_handle, unsigned int ms_timeout, FM_STAGE_REQ_T *req); 

META_RESULT  __stdcall META_FM_GetHighOrLowSide(unsigned int ms_timeout, FM_FREQ_REQ_T *req, FM_HL_Side_CNF_T *cnf);
META_RESULT  __stdcall META_FM_GetHighOrLowSide_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_REQ_T *req, FM_HL_Side_CNF_T *cnf);

META_RESULT  __stdcall META_FM_GetStereoOrMono(unsigned int ms_timeout, FM_Stereo_Mono_CNF_T *cnf);
META_RESULT  __stdcall META_FM_GetStereoOrMono_r(const int meta_handle, unsigned int ms_timeout, FM_Stereo_Mono_CNF_T *cnf);

// for MT6616 new API

META_RESULT  __stdcall META_FM_SetVolume(unsigned int ms_timeout, FM_Volume_Setting_REQ_T *req);
META_RESULT  __stdcall META_FM_SetVolume_r(const int meta_handle, unsigned int ms_timeout, FM_Volume_Setting_REQ_T *req);

META_RESULT  __stdcall META_FM_AutoScan(unsigned int ms_timeout, FM_AutoScan_CNF_T *cnf);
META_RESULT  __stdcall META_FM_AutoScan_r(const int meta_handle, unsigned int ms_timeout, FM_AutoScan_CNF_T *cnf);

META_RESULT  __stdcall META_FM_SetRDS(unsigned int ms_timeout, FM_SetRDS_REQ_T *req);
META_RESULT  __stdcall META_FM_SetRDS_r(const int meta_handle, unsigned int ms_timeout, FM_SetRDS_REQ_T *req);

META_RESULT  __stdcall META_FM_GetRXFilterBW(unsigned int ms_timeout, FM_RX_FilterBW_CNF_T *cnf);
META_RESULT  __stdcall META_FM_GetRXFilterBW_r(const int meta_handle, unsigned int ms_timeout, FM_RX_FilterBW_CNF_T *cnf);

META_RESULT  __stdcall META_FM_GetPAMDLevel(unsigned int ms_timeout, FM_FREQ_REQ_T *req, FM_PAMD_Level_CNF_T *cnf);
META_RESULT  __stdcall META_FM_GetPAMDLevel_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_REQ_T* req, FM_PAMD_Level_CNF_T *cnf);

META_RESULT  __stdcall META_FM_GetMR(unsigned int ms_timeout, FM_MR_CNF_T *cnf);
META_RESULT  __stdcall META_FM_GetMR_r(const int meta_handle, unsigned int ms_timeout, FM_MR_CNF_T *cnf);

META_RESULT  __stdcall META_FM_SetDecodeMode(unsigned int ms_timeout, FM_Decode_Mode_REQ_T *req);
META_RESULT  __stdcall META_FM_SetDecodeMode_r(const int meta_handle, unsigned int ms_timeout, FM_Decode_Mode_REQ_T *req);

META_RESULT  __stdcall META_FM_SetHCC(unsigned int ms_timeout, FM_HCC_REQ_T *req);
META_RESULT  __stdcall META_FM_SetHCC_r(const int meta_handle, unsigned int ms_timeout, FM_HCC_REQ_T *req);

META_RESULT  __stdcall META_FM_SetPAMDThreshold(unsigned int ms_timeout, FM_PAMD_Threshold_REQ_T *req);
META_RESULT  __stdcall META_FM_SetPAMDThreshold_r(const int meta_handle, unsigned int ms_timeout, FM_PAMD_Threshold_REQ_T *req);

META_RESULT  __stdcall META_FM_SetSoftmute(unsigned int ms_timeout, FM_Softmute_Enable_REQ_T *req);
META_RESULT  __stdcall META_FM_SetSoftmute_r(const int meta_handle, unsigned int ms_timeout, FM_Softmute_Enable_REQ_T *req);

META_RESULT  __stdcall META_FM_SetDeemphasisLevel(unsigned int ms_timeout, FM_Deemphasis_Level_REQ_T *req);
META_RESULT  __stdcall META_FM_SetDeemphasisLevel_r(const int meta_handle, unsigned int ms_timeout, FM_Deemphasis_Level_REQ_T *req);

META_RESULT  __stdcall META_FM_SetHLSide(unsigned int ms_timeout, FM_HL_Side_REQ_T *req);
META_RESULT  __stdcall META_FM_SetHLSide_r(const int meta_handle, unsigned int ms_timeout, FM_HL_Side_REQ_T *req);

META_RESULT  __stdcall META_FM_SetDemodBW(unsigned int ms_timeout, FM_Demod_Bandwidth_REQ_T *req);
META_RESULT  __stdcall META_FM_SetDemodBW_r(const int meta_handle, unsigned int ms_timeout, FM_Demod_Bandwidth_REQ_T *req);

META_RESULT  __stdcall META_FM_SetDynamicLimiter(unsigned int ms_timeout, FM_DynamicLimiter_REQ_T *req);
META_RESULT  __stdcall META_FM_SetDynamicLimiter_r(const int meta_handle, unsigned int ms_timeout, FM_DynamicLimiter_REQ_T *req);

META_RESULT  __stdcall META_FM_SetSoftmuteRate(unsigned int ms_timeout, FM_Softmute_Rate_REQ_T *req);
META_RESULT  __stdcall META_FM_SetSoftmuteRate_r(const int meta_handle, unsigned int ms_timeout, FM_Softmute_Rate_REQ_T *req);

// RDS Info
META_RESULT  __stdcall META_FM_GetPI(unsigned int ms_timeout, FM_RDS_Info_REQ_T *req, FM_RDS_Info_CNF_T *cnf);
META_RESULT  __stdcall META_FM_GetPI_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Info_REQ_T *req, FM_RDS_Info_CNF_T *cnf);

META_RESULT  __stdcall META_FM_GetPTY(unsigned int ms_timeout, FM_RDS_Info_REQ_T *req, FM_RDS_Info_CNF_T *cnf);
META_RESULT  __stdcall META_FM_GetPTY_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Info_REQ_T *req, FM_RDS_Info_CNF_T *cnf);

META_RESULT  __stdcall META_FM_GetPS(unsigned int ms_timeout, FM_RDS_Info_REQ_T *req, FM_RDS_Info_CNF_T *cnf);
META_RESULT  __stdcall META_FM_GetPS_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Info_REQ_T *req, FM_RDS_Info_CNF_T *cnf);

META_RESULT  __stdcall META_FM_GetAF(unsigned int ms_timeout, FM_RDS_Info_REQ_T *req, FM_RDS_Info_CNF_T *cnf);
META_RESULT  __stdcall META_FM_GetAF_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Info_REQ_T *req, FM_RDS_Info_CNF_T *cnf);

META_RESULT  __stdcall META_FM_GetRT(unsigned int ms_timeout, FM_RDS_Info_REQ_T *req, FM_RDS_Info_CNF_T *cnf);
META_RESULT  __stdcall META_FM_GetRT_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Info_REQ_T *req, FM_RDS_Info_CNF_T *cnf);

// RDS Status

META_RESULT  __stdcall META_FM_GetTP(unsigned int ms_timeout, FM_RDS_Status_CNF_T *cnf);
META_RESULT  __stdcall META_FM_GetTP_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Status_CNF_T *cnf);

META_RESULT  __stdcall META_FM_GetTA(unsigned int ms_timeout, FM_RDS_Status_CNF_T *cnf);
META_RESULT  __stdcall META_FM_GetTA_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Status_CNF_T *cnf);

META_RESULT  __stdcall META_FM_GetMS(unsigned int ms_timeout, FM_RDS_Status_CNF_T *cnf);
META_RESULT  __stdcall META_FM_GetMS_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Status_CNF_T *cnf);

META_RESULT  __stdcall META_FM_GetGoodBlockCounter(unsigned int ms_timeout, FM_RDS_Good_Block_Counter_CNF_T *cnf);
META_RESULT  __stdcall META_FM_GetGoodBlockCounter_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Good_Block_Counter_CNF_T *cnf);

META_RESULT  __stdcall META_FM_GetBadBlockCounter(unsigned int ms_timeout, FM_RDS_Bad_Block_Counter_CNF_T *cnf);
META_RESULT  __stdcall META_FM_GetBadBlockCounter_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Bad_Block_Counter_CNF_T *cnf);

META_RESULT  __stdcall META_FM_ResetBlockCounter(unsigned int ms_timeout);
META_RESULT  __stdcall META_FM_ResetBlockCounter_r(const int meta_handle, unsigned int ms_timeout);

META_RESULT  __stdcall META_FM_GetGroupCounter(unsigned int ms_timeout, FM_RDS_Group_Counter_CNF_T *cnf);
META_RESULT  __stdcall META_FM_GetGroupCounter_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Group_Counter_CNF_T *cnf);

META_RESULT  __stdcall META_FM_ResetGroupCounter(unsigned int ms_timeout);
META_RESULT  __stdcall META_FM_ResetGroupCounter_r(const int meta_handle, unsigned int ms_timeout);

META_RESULT  __stdcall META_FM_HWSeek(unsigned int ms_timeout, FM_HWSeek_REQ_T *req, FM_HWSeek_CNF_T *cnf);
META_RESULT  __stdcall META_FM_HWSeek_r(const int meta_handle, unsigned int ms_timeout, FM_HWSeek_REQ_T *req, FM_HWSeek_CNF_T *cnf);

META_RESULT  __stdcall META_FM_HWSearch_Stop(unsigned int ms_timeout);
META_RESULT  __stdcall META_FM_HWSearch_Stop_r(const int meta_handle, unsigned int ms_timeout);

META_RESULT  __stdcall META_FM_SetStereoBlend(unsigned int ms_timeout, FM_SetStereoBlend_REQ_T* req);
META_RESULT  __stdcall META_FM_SetStereoBlend_r(const int meta_handle, unsigned int ms_timeout, FM_SetStereoBlend_REQ_T* req);

META_RESULT  __stdcall META_FM_GetRDSLogData(unsigned int ms_timeout, FM_RDS_Block_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetRDSLogData_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Block_CNF_T* cnf);

META_RESULT  __stdcall META_FM_GetRDSBLERRatio(unsigned int ms_timeout, unsigned short* bler);
META_RESULT  __stdcall META_FM_GetRDSBLERRatio_r(const int meta_handle, unsigned int ms_timeout, unsigned short* bler);

typedef void (__stdcall *META_FM_RDS_INFO_UPDATE_CNF)(const FM_RDS_Info_CNF_T *cnf, const short token, void *usrData);
typedef void (__stdcall *META_FM_RDS_STATUS_UPDATE_CNF)(const FM_RDS_Status_CNF_T *cnf, const short token, void *usrData);
typedef struct
{
	META_FM_RDS_INFO_UPDATE_CNF m_RDSInfoUpdateCallback;
	META_FM_RDS_STATUS_UPDATE_CNF m_RDSStatusUpdateCallback;
} FM_RDSCallBack;
META_RESULT  __stdcall META_FM_RegisterRDSInfoUpdateCallback(META_FM_RDS_INFO_UPDATE_CNF cb);
META_RESULT  __stdcall META_FM_RegisterRDSInfoUpdateCallback_r(const int meta_handle, META_FM_RDS_INFO_UPDATE_CNF cb);
META_RESULT  __stdcall META_FM_RegisterRDSStatusUpdateCallback(META_FM_RDS_STATUS_UPDATE_CNF cb);
META_RESULT  __stdcall META_FM_RegisterRDSStatusUpdateCallback_r(const int meta_handle, META_FM_RDS_STATUS_UPDATE_CNF cb);
META_RESULT  __stdcall META_FM_RemoveRDSInfoUpdateCallback(void);
META_RESULT  __stdcall META_FM_RemoveRDSInfoUpdateCallback_r(const int meta_handle);
META_RESULT  __stdcall META_FM_RemoveRDSStatusUpdateCallback(void);
META_RESULT  __stdcall META_FM_RemoveRDSStatusUpdateCallback_r(const int meta_handle);

META_RESULT  __stdcall META_FM_GetAntennaType(unsigned int ms_timeout, char* type);
META_RESULT  __stdcall META_FM_GetAntennaType_r(const int meta_handle, int ms_timeout, char* type);
META_RESULT  __stdcall META_FM_SetAntennaType(unsigned int ms_timeout, char type);
META_RESULT  __stdcall META_FM_SetAntennaType_r(const int meta_handle, int ms_timeout, char type);
//----------------------------------------------------------------//
//                            TDMB                                //
//----------------------------------------------------------------//

//--------------------------//
//    TDMB data structures  //
//--------------------------//

typedef enum {   // ref from TDMB
   META_TDMB_KOREA_BAND=1,
   META_TDMB_BAND_III,
   META_TDMB_L_BAND,
   META_TDMB_CANADA_BAND,
   META_TDMB_CHINESE_BAND,
   META_TDMB_BAND_II,
   META_TDMB_BAND_IF,
   META_TDMB_UNDEF_BAND
} META_TDMB_BAND_enum;

typedef struct
{
    META_TDMB_BAND_enum  m_rBand;
	
}TDMB_SET_BAND_REQ_T;

typedef struct
{
   unsigned int  m_u4Freq;
}TDMB_SET_FREQ_REQ_T;



typedef struct
{
	unsigned char m_ucFreqNum;
	unsigned int m_u4Freq[10];
   
}TDMB_AUTO_SCAN_CNF_T;

// ========  for Ensemble ========


typedef struct
{
	//TDMB_DBSTATE	   DB;
	unsigned char        m_ucStateNum;
	unsigned int		 m_u4State[10];


	unsigned int		Type;   //DMB,DAB,DATA
	unsigned int		Id;
	unsigned int		BitRate;
	unsigned char		PL; //Protection Level
	unsigned char		Reg[8];
	unsigned short		UserApplType;		// added by KST 2006.07.20

	unsigned int		TMId;
	unsigned int		ASCTy_DSCTy;
	unsigned int		SCId;
	unsigned int		PackAdd;
	unsigned int		DG_MFflag;
	unsigned int		Primary;
	unsigned int		CAflag;
	unsigned int		Language;
	char				SCLabel[16];
 
	//TDMB_SvcComponentInfo	 *pSvcComp;
	unsigned char		SvcComp_Order;			// 4bits
	unsigned char		SvcComp_TMId;			// 2bits	Transport Mechanism Id
	unsigned char		SvcComp_ASCTy_DSCTy;	// 6bits	Audio Service Component Type	
	unsigned char		SvcComp_SubCh_FIDCId;	// 6bits	SubChId or FIDCId in FIG 0/4
	unsigned int		SvcComp_SId;			// 16bit
	unsigned char		SvcComp_CAflag;			// 1bit		CA Flag
	unsigned char		SvcComp_DG_MFflag;		// 1bit		DG Flag or MF flag
	unsigned char		SvcComp_Language;		// 8bit
	unsigned char		SvcComp_SCIdS;			// 4bit		Service component Identifier within ther Service
	unsigned char       SvcComp_SvcCompLabel[16];// 16bytes Service component Label	

	unsigned short		SvcComp_SCId;			// 12bits	Service Component Id
	unsigned short		SvcComp_PackAdd;		// 10bits	Packet Address
	unsigned short		SvcComp_SCCA;			// 16bits	Service Component Conditional Access

	unsigned short      SvcComp_m_encoded_id;   // Only for Frontier
    unsigned char       SvcComp_m_sif;          // Only for Frontier	


	//TDMB_SubChInfo			 *pSubCh;
	unsigned char	    SubChId;		// 6bits	Sub channel Id
	unsigned char	    TblIndex;		// 6bits	TableIndex
	unsigned char	    Form_Opt_Prot;  //[3] : FormFlag   //[2] : Option//[1~0] : protection
	unsigned short	    StrtAdd;		// 10bits	Start Address
	unsigned short	    SubChSize;		// 10bits	Sub channel size

	unsigned int		Tag;

}TDMB_CHANNELDB_T;

typedef struct
{
	// TDMB_DBSTATE
	unsigned char       m_ucStateNum;
	unsigned int		m_u4State[10];

	unsigned int		Id;
	char				Label[20];

	//TDMB_ServiceInfo  *pService;
	unsigned int		SId;			// 32bits	
	unsigned char		SvcLabel[16];	// 16bytes	Service Label(Program service and Data service)
	unsigned short		CharacterFlag;
	unsigned char		CAId;			// 3bit
	unsigned char		NumSvcComp;		// 4bits	Number of Service Component	


	//TDMB_CHANNELDB		*Channel;
  unsigned char     m_ucChannelDBNum;
	TDMB_CHANNELDB_T  m_rChannelDB[10];


	//struct _TDMB_SERVICEDB	*Next;
	unsigned int				Tag;
	unsigned int			ChannelCount;


}TDMB_SERVICEDB_T; 

typedef struct
{
	// TDMB_DBSTATE
	unsigned char        m_ucStateNum;
	unsigned int		 m_u4State[10];

	unsigned int		 Band;
    unsigned int		 Frequency;
    unsigned short		 Id;
    unsigned int		 SvcNum;
    unsigned int		 SvcCompNum;
    unsigned int		 SubChNum;
	char				 Label[20];

	// TDMB_EnsembleInfo
	unsigned char	AlFlag;				// 1bit		Al flag
	unsigned char   NumSubCh;
	unsigned char   NumSvc;
	unsigned char	NumProgram;
	unsigned char   NumSvcComp;
	unsigned char	NumUserApp;
	unsigned char	NumAnn;
	unsigned char	NumProgType;
	unsigned char	EnsemLabel[16];		// 16bytes	Ensemble Label
	unsigned short  CharacterFlag;
	unsigned short	EId;				// 16bits	country Id Ensemble reference

	// TDMB_SERVICEDB[]
	unsigned char   m_ucServiceDBNum;
	TDMB_SERVICEDB_T  m_rServiceDB[10];

	unsigned int     Tag;

}TDMB_ENSEMBLEDB_T;


typedef struct   // for META APP
{
   unsigned char      m_ucEnsembleNum;
   TDMB_ENSEMBLEDB_T  m_rEnsembleDB[10];

}TDMB_GET_ENSM_INFO_BY_AUTO_SCAN_CNF_T;

typedef struct   // for META APP
{
	char m_cResult; // 0: success, 
	                // 1: the band not exist  ==> META_TDMB_ERR_BAND_NOT_EXIST
	                // 2: frequency not exist ==> META_TDMB_ERR_FREQ_NOT_EXIST

	unsigned char      m_ucEnsembleNum;
    TDMB_ENSEMBLEDB_T  m_rEnsembleDB[10];
	TDMB_ENSEMBLEDB_T  m_rCurEnsembleDB;

}TDMB_SET_FREQ_CNF_T;


typedef struct
{
	unsigned short m_u2Snr;
	unsigned char  m_ucBer_a;  // a.b*10^-c
	unsigned char  m_ucBer_b;
	unsigned char  m_ucBer_c;
	short          m_i2RSSI; 

}TDMB_GET_SIGNAL_CNF_T;

typedef struct
{
	unsigned int m_u4ServiceId;
	unsigned int m_u4SubChnId;
	char         *m_pcfilepath; // store the TS stream data to this file 

}TDMB_SEL_SERVICE_REQ_T;

typedef struct  
{
	unsigned int m_u4ServiceId;
	unsigned int m_u4SubChnId;

}TDMB_SEL_SERVICE_ONLY_REQ_T;



typedef struct  //  for Meta APP only
{
	unsigned char      m_ucEnsembleNum;
    TDMB_ENSEMBLEDB_T  m_rEnsembleDB[10];
	TDMB_ENSEMBLEDB_T  m_rCurEnsembleDB;

}TDMB_GET_ENSM_CNF_T;
// --------------------------//
//      TDMB callback        //
// --------------------------//
typedef enum
{
    TDMB_FAT_DISK_FULL = 0
   ,TDMB_FAT_UNKNOWN_WRITE_ERROR
   ,TDMB_MED_MEMORY_FULL
   ,TDMB_MED_MEMORY_NOT_EXIST

}TDMB_SEL_SERV_ERROR_RESULT;

typedef void (__stdcall *META_TDMB_SEL_SERV_CNF)(const TDMB_SEL_SERV_ERROR_RESULT status);

//--------------------------//
//      TDMB Functions      //
//--------------------------//

META_RESULT  __stdcall META_TDMB_TurnOn(unsigned int ms_timeout);
META_RESULT  __stdcall META_TDMB_TurnOn_r(const int meta_handle, unsigned int ms_timeout);

// send band may return: META_TDMB_ERR_BAND_NOT_EXIST, META_SUCCESS, META_FAILED
META_RESULT __stdcall META_TDMB_SetBand(unsigned int ms_timeout, TDMB_SET_BAND_REQ_T *req);
META_RESULT __stdcall META_TDMB_SetBand_r(const int meta_handle, unsigned int ms_timeout, TDMB_SET_BAND_REQ_T *req);

META_RESULT __stdcall META_TDMB_AutoScan_GetFreq(unsigned int ms_timeout, TDMB_AUTO_SCAN_CNF_T *cnf);
META_RESULT __stdcall META_TDMB_AutoScan_GetFreq_r(const int meta_handle, unsigned int ms_timeout, TDMB_AUTO_SCAN_CNF_T *cnf);

META_RESULT __stdcall META_TDMB_SetFreq(unsigned int ms_timeout, TDMB_SET_FREQ_REQ_T *req, TDMB_SET_FREQ_CNF_T *cnf);
META_RESULT __stdcall META_TDMB_SetFreq_r(const int meta_handle, unsigned int ms_timeout, TDMB_SET_FREQ_REQ_T *req, TDMB_SET_FREQ_CNF_T *cnf);

META_RESULT __stdcall META_TDMB_AutoScan_GetEnsemble(unsigned int ms_timeout, TDMB_GET_ENSM_INFO_BY_AUTO_SCAN_CNF_T *cnf);
META_RESULT __stdcall META_TDMB_AutoScan_GetEnsemble_r(const int meta_handle, unsigned int ms_timeout, TDMB_GET_ENSM_INFO_BY_AUTO_SCAN_CNF_T *cnf);

META_RESULT __stdcall META_TDMB_GetSignal(unsigned int ms_timeout, TDMB_GET_SIGNAL_CNF_T *cnf);
META_RESULT __stdcall META_TDMB_GetSignal_r(const int meta_handle, unsigned int ms_timeout, TDMB_GET_SIGNAL_CNF_T *cnf);

//META_RESULT __stdcall META_TDMB_SelService(unsigned int ms_timeout, TDMB_SEL_SERVICE_REQ_T *req);
//META_RESULT __stdcall META_TDMB_SelService_r(const int meta_handle, unsigned int ms_timeout, TDMB_SEL_SERVICE_REQ_T *req);

META_RESULT __stdcall META_TDMB_SelService(unsigned int ms_timeout, TDMB_SEL_SERVICE_REQ_T *req, const META_TDMB_SEL_SERV_CNF  cnf_cb);
META_RESULT __stdcall META_TDMB_SelService_r(const int meta_handle, unsigned int ms_timeout, TDMB_SEL_SERVICE_REQ_T *req, const META_TDMB_SEL_SERV_CNF  cnf_cb);

//META_RESULT __stdcall META_TDMB_SetIdle(unsigned int ms_timeout);
//META_RESULT __stdcall META_TDMB_SetIdle_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT __stdcall META_TDMB_SetIdle(unsigned int ms_timeout, CALLBACK_META_FAT_PROGRESS  cb_progress, void  *cb_progress_arg);
META_RESULT __stdcall META_TDMB_SetIdle_r(const int meta_handle, unsigned int ms_timeout, CALLBACK_META_FAT_PROGRESS  cb_progress, void  *cb_progress_arg);


META_RESULT __stdcall META_TDMB_TurnOff(unsigned int ms_timeout);
META_RESULT __stdcall META_TDMB_TurnOff_r(const int meta_handle, unsigned int ms_timeout);

META_RESULT __stdcall META_TDMB_GetEnsm(unsigned int ms_timeout, TDMB_GET_ENSM_CNF_T *cnf);
META_RESULT __stdcall META_TDMB_GetEnsm_r(const int meta_handle, unsigned int ms_timeout, TDMB_GET_ENSM_CNF_T *cnf);

META_RESULT __stdcall META_TDMB_SelServiceOnly( unsigned int ms_timeout, TDMB_SEL_SERVICE_ONLY_REQ_T *req);
META_RESULT __stdcall META_TDMB_SelServiceOnly_r(const int meta_handle, unsigned int ms_timeout, TDMB_SEL_SERVICE_ONLY_REQ_T *req);


META_RESULT __stdcall META_TDMB_StopAutoScan(unsigned int ms_timeout);
META_RESULT __stdcall META_TDMB_StopAutoScan_r(const int meta_handle, unsigned int ms_timeout);

//----------------------------------------------------------------------//
//       META Misc: backup and restore calibration Data
//----------------------------------------------------------------------//


typedef void (__stdcall *CALLBACK_MISC_PROGRESS)(unsigned char m_u1TotalNum, unsigned char m_u1BackupNum, void *usr_arg);
typedef void (__stdcall *CALLBACK_MISC_IMEI_PROGRESS)(const int imei_max_num, const char** errMsg, const char** imei, void *usr_arg);

typedef enum
{
	META_STORAGE_TYPE_FAT = 0	
   ,META_STORAGE_TYPE_OTP		
   ,META_STORAGE_TYPE_SECRO	
   ,META_STORAGE_TYPE_END

}META_IMEI_LOC_enum;

typedef struct
{
	char                    *m_pIniFilePath;
	char                    *m_pBackupFolderPath; // Let customer choose the backup folder
	                                              //Note: it should be different by meta_handle!
    CALLBACK_MISC_PROGRESS  cb_progress;
	void                    *cb_progress_arg;
}MISC_BACKUP_REQ_T;



typedef struct
{
	char                    *m_pIniFilePath;
	char                    *m_pBackupFolderPath; // the folder which store the backup data
    CALLBACK_MISC_PROGRESS   cb_progress;
	void                     *cb_progress_arg;

}MISC_RESTORE_REQ_T;




typedef struct
{
	char                 m_strBackupFolder[MAX_PATH];
	bool                 m_bISNewLoad;
	META_IMEI_LOC_enum   m_enumImeiLoc; // only valid when m_bISNewLoad = true;
	unsigned  char       m_ImeiData[10]; // only valid when m_bISNewLoad = true
	int                  m_i4ComPort;
	int                  m_i4BackupFileNum;

}BACKUP_RESULT_T;

typedef struct
{
	
	char                    m_strRestoreFromFolder[MAX_PATH];
	bool                    m_bISNewLoad;
	META_IMEI_LOC_enum      m_enumImeiLoc; // only valid when m_bISNewLoad = true;
	unsigned char           m_ImeiData[10]; // only valid when m_bISNewLoad = true;
	int                     m_i4ComPort;
	int                     m_i4BackupFileNum;
	

}RESTORE_RESULT_T;

typedef struct
{
	char                    *m_pIniFilePath; // the INI file path
    CALLBACK_MISC_PROGRESS   cb_progress;
	void                     *cb_progress_arg;

}MISC_UPLOAD_REQ_T;

typedef struct
{
    char                    *m_pIniFilePath; // the INI file path
    CALLBACK_MISC_PROGRESS   cb_progress;
    void                     *cb_progress_arg;
    CALLBACK_MISC_IMEI_PROGRESS   cb_imei_progress;
    void                     *cb_imei_progress_arg;
}MISC_UPLOAD_REQ_EX_T;

typedef struct {
	char			imei[16];
	unsigned short record_index;
	// temp solution
	unsigned char svn;
}META_SET_IMEI_T;


META_RESULT __stdcall META_MISC_GetIMEILocation(const unsigned int ms_timeout, META_IMEI_LOC_enum *storagetype);
META_RESULT __stdcall META_MISC_GetIMEILocation_r(const int meta_handle, const unsigned int ms_timeout, META_IMEI_LOC_enum *storagetype);
META_RESULT __stdcall META_MISC_GetIMEIRecNum(const unsigned int ms_timeout, unsigned short *rec_num);
META_RESULT __stdcall META_MISC_GetIMEIRecNum_r(const int meta_handle, const unsigned int ms_timeout, unsigned short *rec_num);

META_RESULT __stdcall META_MISC_QueryNVRAMFolderAmount(const unsigned int ms_timeout, unsigned char* folder_amount);
META_RESULT __stdcall META_MISC_QueryNVRAMFolderAmount_r(const int meta_handle, const unsigned int ms_timeout, unsigned char* folder_amount);

META_RESULT __stdcall META_MISC_CheckSIM1Inserted(const unsigned int ms_timeout,unsigned char* inserted);
META_RESULT __stdcall META_MISC_CheckSIM1Inserted_r(const int meta_handle, const unsigned int ms_timeout, unsigned char* inserted);

META_RESULT __stdcall META_MISC_CheckSIM2Inserted(const unsigned int ms_timeout,unsigned char* inserted);
META_RESULT __stdcall META_MISC_CheckSIM2Inserted_r(const int meta_handle, const unsigned int ms_timeout, unsigned char* inserted);

META_RESULT __stdcall META_MISC_CheckGeminiPlusSIMInserted(const unsigned int ms_timeout, unsigned char sim_module_index, unsigned char* inserted);
META_RESULT __stdcall META_MISC_CheckGeminiPlusSIMInserted_r(const int meta_handle, const unsigned int ms_timeout, unsigned char sim_module_index, unsigned char* inserted);

#define MUIC_MODE_CHARGE_ON     0
#define MUIC_MODE_CHARGE_OFF    1
#define MUIC_MODE_USB_500       2
#define MUIC_MODE_ISET_PROGRAM  3
#define MUIC_MODE_USB_100       4
#define MUIC_MODE_TEST_MODE     5
#define MUIC_MODE_USB_100_2     6

META_RESULT __stdcall META_MISC_SetMuicChargerMode(const unsigned int ms_timeout, const unsigned char* req_mode);
META_RESULT __stdcall META_MISC_SetMuicChargerMode_r(const int meta_handle, const unsigned int ms_timeout, const unsigned char* req_mode);


typedef struct
{
	const char			*LID;		// The name of logical data item ID
	//signed short      u2LIDEnumVal;
	unsigned short		u2RID;	// Record ID (the first record is 1)
} META_MISC_CAL_DATA_INTEGRITY_ENTRY;

typedef struct
{

	bool                bAllPass;  // true: check pass, false: no items or check fail
	unsigned short      u2LastLID;  // valid when bAllPass == false
	unsigned short      u2LastRID;  // valid when bAllPass == false
} META_MISC_CAL_DATA_INTEGRITY_CHECK_CNF_T;


META_RESULT __stdcall META_MISC_CalDataIntegrity_StartRec(const unsigned int ms_timeout);
META_RESULT __stdcall META_MISC_CalDataIntegrity_StartRec_r(const int meta_handle, const unsigned int ms_timeout);
META_RESULT __stdcall META_MISC_CalDataIntegrity_StopRec(const unsigned int ms_timeout, int *rec_num);
META_RESULT __stdcall META_MISC_CalDataIntegrity_StopRec_r(const int meta_handle, const unsigned int ms_timeout, int *rec_num);
META_RESULT __stdcall META_MISC_CalDataIntegrity_AddOne(const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY *req);
META_RESULT __stdcall META_MISC_CalDataIntegrity_AddOne_r(const int meta_handle, const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY *req);

META_RESULT __stdcall META_MISC_CalDataIntegrity_DelOne(const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY *req);
META_RESULT __stdcall META_MISC_CalDataIntegrity_DelOne_r(const int meta_handle, const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY *req);
META_RESULT __stdcall META_MISC_CalDataIntegrity_DelAll(const unsigned int ms_timeout);
META_RESULT __stdcall META_MISC_CalDataIntegrity_DelAll_r(const int meta_handle, const unsigned int ms_timeout);
META_RESULT __stdcall META_MISC_CalDataIntegrity_CheckOne(const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY *req);
META_RESULT __stdcall META_MISC_CalDataIntegrity_CheckOne_r(const int meta_handle, const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY *req);
META_RESULT __stdcall META_MISC_CalDataIntegrity_CheckAll(const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_CHECK_CNF_T *cnf);
META_RESULT __stdcall META_MISC_CalDataIntegrity_CheckAll_r(const int meta_handle, const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_CHECK_CNF_T *cnf);


#define META_MISC_SUPPORTED_MAX_ADC_CHN_NUM 20

typedef struct
{
	bool bADCStoredInEfuse;  // true: ADC is stored in EFUSE, not in NVRAM data.
	int  i4ADCChnNum;  // specify the adc channel number supported by this phone
	int  i4ADCSlope[META_MISC_SUPPORTED_MAX_ADC_CHN_NUM]; // [0 ~ iADCChnNum-1] is valid when bADCStoredInEfuse = true
    int  i4ADCOffset[META_MISC_SUPPORTED_MAX_ADC_CHN_NUM];// [0 ~ iADCChnNum-1] is valid when bADCStoredInEfuse = true
}META_MISC_GET_ADC_FROM_EFUSE_CNF_T;

META_RESULT __stdcall META_MISC_GetADCFromEFuse(const unsigned int ms_timeout, META_MISC_GET_ADC_FROM_EFUSE_CNF_T *cnf);
META_RESULT __stdcall META_MISC_GetADCFromEFuse_r(const int meta_handle, const unsigned int ms_timeout, META_MISC_GET_ADC_FROM_EFUSE_CNF_T *cnf);

META_RESULT __stdcall META_MISC_GetCalFlagEnum(const unsigned int ms_timeout, unsigned short *u2EnumVal);
META_RESULT __stdcall META_MISC_GetCalFlagEnum_r(const int meta_handle, const unsigned int ms_timeout, unsigned short *u2EnumVal);

META_RESULT __stdcall META_MISC_GetRfCalEnvEnum(const unsigned int ms_timeout, unsigned short *u2EnumVal);
META_RESULT __stdcall META_MISC_GetRfCalEnvEnum_r(const int meta_handle, const unsigned int ms_timeout, unsigned short *u2EnumVal);
META_RESULT __stdcall META_MISC_GetRfCalLossSettingEnum(const unsigned int ms_timeout, unsigned short *u2EnumVal);
META_RESULT __stdcall META_MISC_GetRfCalLossSettingEnum_r(const int meta_handle, const unsigned int ms_timeout, unsigned short *u2EnumVal);
META_RESULT __stdcall META_MISC_GetRfTestPowerResultEnum(const unsigned int ms_timeout, unsigned short *u2EnumVal);
META_RESULT __stdcall META_MISC_GetRfTestPowerResultEnum_r(const int meta_handle, const unsigned int ms_timeout, unsigned short *u2EnumVal);

META_RESULT __stdcall META_MISC_GetADCMaxChannel(const unsigned int ms_timeout, unsigned char *u1Val);
META_RESULT __stdcall META_MISC_GetADCMaxChannel_r(const int meta_handle, const unsigned int ms_timeout, unsigned char *u1Val);
META_RESULT __stdcall META_MISC_GetTADCChannelIndex(const unsigned int ms_timeout, unsigned char *u1Val);
META_RESULT __stdcall META_MISC_GetTADCChannelIndex_r(const int meta_handle, const unsigned int ms_timeout, unsigned char *u1Val);

META_RESULT __stdcall META_MISC_GetRID(const unsigned int ms_timeout,unsigned char *u1Rid,const unsigned int ui_RidLen);
META_RESULT __stdcall META_MISC_GetRID_r(const int meta_handle,const unsigned int ms_timeout,unsigned char *u1Rid,const unsigned int ui_RidLen);

META_RESULT __stdcall META_BackupCalibrationData(const MISC_BACKUP_REQ_T *req, int *p_backupstop );
META_RESULT __stdcall META_BackupCalibrationData_r(const int meta_handle, const MISC_BACKUP_REQ_T *req, int *p_backupstop);
META_RESULT __stdcall META_RestoreCalibrationData(const MISC_RESTORE_REQ_T *req, int *p_restorestop);
META_RESULT __stdcall META_RestoreCalibrationData_r(const int meta_handle, const MISC_RESTORE_REQ_T *req, int *p_restorestop);


META_RESULT __stdcall META_DeleteAllFilesInBackupFolder(const char *pBackupFolderPath);
META_RESULT __stdcall META_DeleteAllFilesInBackupFolder_r(const int meta_handle, const char *pBackupFolderPath);


META_RESULT __stdcall META_GetRestoreResultInfo_r(const int meta_handle, const char *backup_folder, RESTORE_RESULT_T *cnf);
META_RESULT __stdcall META_GetRestoreResultInfo(const char *backup_folder, RESTORE_RESULT_T *cnf);
META_RESULT __stdcall META_GetBackupResultInfo(const char *backup_folder, BACKUP_RESULT_T *cnf);
META_RESULT __stdcall META_GetBackupResultInfo_r(const int meta_handle, const char *backup_folder, BACKUP_RESULT_T *cnf);

// be used in old load when IMEI and SML NVRAM files can not be accessed by File System APIs!
// i.e., IMEI and SML NVRAM files will not be backuped and restored!
META_RESULT __stdcall META_BasicBackupCalibrationData_r(const int meta_handle, const MISC_BACKUP_REQ_T *req, int *p_backupstop);
META_RESULT __stdcall META_BasicBackupCalibrationData(const MISC_BACKUP_REQ_T *req, int *p_backupstop);
META_RESULT __stdcall META_BasicRestoreCalibrationData_r(const int meta_handle, const MISC_RESTORE_REQ_T *req, int *p_restorestop);
META_RESULT __stdcall META_BasicRestoreCalibrationData(const MISC_RESTORE_REQ_T *req, int *p_restorestop);

META_RESULT __stdcall META_UploadFilesToTarget(MISC_UPLOAD_REQ_T *req, int *p_uploadstop);
META_RESULT __stdcall META_UploadFilesToTarget_r(const int meta_handle, MISC_UPLOAD_REQ_T *req, int *p_uploadstop);
META_RESULT __stdcall META_UploadFilesToTarget_Ex(MISC_UPLOAD_REQ_EX_T *req, int *p_uploadstop);
META_RESULT __stdcall META_UploadFilesToTarget_Ex_r(const int meta_handle, MISC_UPLOAD_REQ_EX_T *req, int *p_uploadstop);

META_RESULT __stdcall META_MISC_GetMmiCacheEnumIndex(const unsigned int ms_timeout, unsigned short enum_value, unsigned short *index);
META_RESULT __stdcall META_MISC_GetMmiCacheEnumIndex_r(const int meta_handle, const unsigned int ms_timeout, unsigned short enum_value, unsigned short *index);
typedef struct
{
	  unsigned char sec;    // seconds after the minute   - [0,59]
	  unsigned char min;    // minutes after the hour     - [0,59] 
	  unsigned char hour;   // hours after the midnight   - [0,23]  
	  unsigned char day;    // day of the month           - [1,31]  
	  unsigned char mon;    // months 		                  - [1,12]  
	  unsigned char wday;   // days in a week 		          - [1,7]; not correct information, so don't care.   
	  unsigned char year;   // years                      - [0,127] 
} META_RCT_INFO_T; 

#define META_ERS_FILE_NAME_WCHAR_CNT  100

typedef struct
{
    WCHAR            wQueryKey[META_ERS_FILE_NAME_WCHAR_CNT];//ers_filename[META_ERS_FILE_NAME_WCHAR_CNT];
	META_RCT_INFO_T  ers_ctime;
} META_ERS_INFO_T;


META_RESULT __stdcall META_MISC_EX_GetErsCount(const unsigned int ms_timeout,  int *pCnt);
META_RESULT __stdcall META_MISC_EX_GetErsCount_r(const int meta_handle, const unsigned int ms_timeout, int *pCnt);
META_RESULT __stdcall META_MISC_EX_GetErsDataInfoByIndex(const unsigned int ms_timeout,  const int index, META_ERS_INFO_T *pCnf);
META_RESULT __stdcall META_MISC_EX_GetErsDataInfoByIndex_r(const int meta_handle, const unsigned int ms_timeout, const int index, META_ERS_INFO_T *pCnf);

META_RESULT __stdcall META_MISC_EX_GetErsSize(const unsigned int ms_timeout, unsigned int *pSize);
META_RESULT __stdcall META_MISC_EX_GetErsSize_r(const int meta_handle, const unsigned int ms_timeout, unsigned int *pSize);
//META_RESULT __stdcall META_MISC_EX_GetErsData(const unsigned int ms_timeout, const unsigned int ers_data_buf_size, unsigned char *ers_data_buffer);
//META_RESULT __stdcall META_MISC_EX_GetErsData_r(const int meta_handle, const unsigned int ms_timeout, const unsigned int ers_data_buf_size, unsigned char *ers_data_buffer);
META_RESULT __stdcall META_MISC_EX_GetErsData(const unsigned int ms_timeout, WCHAR *wfilepath, const unsigned int ers_data_buf_size, unsigned char *ers_data_buffer);
META_RESULT __stdcall META_MISC_EX_GetErsData_r(const int meta_handle, const unsigned int ms_timeout, WCHAR *wfilepath, const unsigned int ers_data_buf_size, unsigned char *ers_data_buffer);

META_RESULT __stdcall META_MISC_EX_InitBPAreaFromNVRAM(const unsigned int ms_timeout);
META_RESULT __stdcall META_MISC_EX_InitBPAreaFromNVRAM_r(const int meta_handle, const unsigned int ms_timeout);
typedef enum
{
	META_BP_AREA_STATUS_OK = 0
   ,META_BP_AREA_STATUS_EMPTY
   ,META_BP_AREA_STATUS_BROKEN
   ,META_BP_AREA_STATUS_NO_SYNC
   ,META_BP_AREA_STATUS_UNKNOWN
}META_BP_AREA_STATUS_E;
META_RESULT __stdcall META_MISC_EX_VerifyBPArea(const unsigned int ms_timeout, bool *bFastVerify, META_BP_AREA_STATUS_E *cnf);
META_RESULT __stdcall META_MISC_EX_VerifyBPArea_r(const int meta_handle, const unsigned int ms_timeout, bool *bFastVerify, META_BP_AREA_STATUS_E *cnf);
META_RESULT __stdcall META_MISC_EX_SwitchSDSMode(const unsigned int ms_timeout, unsigned int sds_mode, unsigned int *sds_status);
META_RESULT __stdcall META_MISC_EX_SwitchSDSMode_r(const int meta_handle, const unsigned int ms_timeout, unsigned int sds_mode, unsigned int *sds_status);
META_RESULT __stdcall META_MISC_EX_GetSDSMode(const unsigned int ms_timeout, unsigned int *sds_mode);
META_RESULT __stdcall META_MISC_EX_GetSDSMode_r(const int meta_handle, const unsigned int ms_timeout, unsigned int *sds_mode);
//----------------------------------------------------------------//
//                            CMMB                                //
//----------------------------------------------------------------//

#define   META_CMMB_FREQ_BAND_NUM  4
#define   META_CMMB_FRAME_INFO_NUM 4

#define   META_CMMB_BLK_NUM        8
#define   META_CMMB_SERV_BLOCK_NUM   20
#define   META_CMMB_DATA_BLK_NUM     128

//--------------------------//
//    CMMB data structures  //
//--------------------------//
typedef enum
{

   META_CMMB_CHINA_U_BAND=0
  ,META_CMMB_TAIWAN_BAND   
  ,META_CMMB_UNDEF_BAND
}META_CMMB_BAND_enum;

typedef struct
{
    META_CMMB_BAND_enum  m_rBand;
	
}META_CMMB_SET_BAND_REQ_T;



typedef struct
{
    unsigned char   m_u1FreqPointId;
	unsigned char   m_u1BandWidth;
	unsigned int    m_u4Freq;
	
}META_CMMB_FreqBandStruct_T;


typedef struct
{
   unsigned char   m_u1StartFreqPointId;
   unsigned char   m_u1EndFreqPointId;
   
}META_CMMB_FREQ_RANGE_FOR_AUTO_SCAN_REQ_T;


typedef struct
{
	unsigned char                   m_u1MainFreqNum;  
	META_CMMB_FreqBandStruct_T      m_rMainFreqBand[META_CMMB_FREQ_BAND_NUM]; 
	 
}META_CMMB_AUTO_SCAN_GET_FREQ_CNF_T;



//==================================================================



typedef struct 
{
	unsigned char                   Nit_NitUpdateSeq;     
    unsigned char                   Nit_SysTime[5]   ;    
    unsigned int                    Nit_CountryCode ;     
       
    unsigned char                   Nit_Net_NetLevel;
    unsigned short                  Nit_Net_NetId;
  
    unsigned char                   Nit_NetNameLen  ;    
     
       
    unsigned char                   Nit_NetName[128];      
       
    unsigned char                   Nit_FreqBand_FreqPointId;
    unsigned char					Nit_FreqBand_BandWidth;  
    unsigned int					Nit_FreqBand_CenterFreq; 
   
    unsigned char                   Nit_OtherFreqNum;    // at most 8 here transferred by ft task.
    unsigned char                   m_ucOtherFreqNumWeCarry; 
    
       
    unsigned char                   Nit_OtherFreqBandList_FreqPointId[META_CMMB_BLK_NUM];
    unsigned char                   Nit_OtherFreqBandList_BandWidth[META_CMMB_BLK_NUM];  
    unsigned int                    Nit_OtherFreqBandList_CenterFreq[META_CMMB_BLK_NUM]; 
  
  
    unsigned char                   Nit_NeighborNetNum;  // at most 8 here transferred by ft task.   
    unsigned char                   m_ucNeightborNetWeCarray;         
                                     
    unsigned char                   Nit_NeighborNetList_NetLevel[META_CMMB_BLK_NUM];
    unsigned short                  Nit_NeighborNetList_NetId[META_CMMB_BLK_NUM];
    unsigned char                   Nit_NeighborNetList_FreqPointId[META_CMMB_BLK_NUM];
    unsigned char                   Nit_NeighborNetList_BandWidth[META_CMMB_BLK_NUM];  
    unsigned int                    Nit_NeighborNetList_CenterFreq[META_CMMB_BLK_NUM];
    
   
}META_CMMB_NitStruct_T;

typedef struct  
{
	unsigned char                        MctUpdateSeq;
    unsigned char                        FreqPointId; 
    
    
    unsigned char                        MfNum;  
    
    unsigned char                        m_ucMfNumWeCarray;  
    
   
    unsigned char                        Mf_MfId[META_CMMB_BLK_NUM];              
    unsigned char                        Mf_RsRate[META_CMMB_BLK_NUM];            
    unsigned char                        Mf_ByteInterleaveMode[META_CMMB_BLK_NUM];
    unsigned char                        Mf_LdpcRate[META_CMMB_BLK_NUM];          
    unsigned char                        Mf_ModulationMode[META_CMMB_BLK_NUM];    
    unsigned char                        Mf_ScrambleMode[META_CMMB_BLK_NUM]; 
         
    unsigned char                        Mf_TimeSlotNum[META_CMMB_BLK_NUM]; 
    
    unsigned char                        m_ucMf_TimeSlotNumWeCarray[META_CMMB_BLK_NUM]; 
    
    unsigned char                        Mf_TimeSlotId[META_CMMB_BLK_NUM][META_CMMB_BLK_NUM]; 
            
    unsigned char                        Mf_SubMfNum[META_CMMB_BLK_NUM];
    unsigned char                        m_ucMf_SubMfNumWeCarry[META_CMMB_BLK_NUM];
              

    unsigned char                        Mf_SubMfId[META_CMMB_BLK_NUM][META_CMMB_BLK_NUM];
    unsigned short                       Mf_serviceId[META_CMMB_BLK_NUM][META_CMMB_BLK_NUM];      
	 
}META_CMMB_MctStruct_T;

typedef struct 
{
   unsigned char                    SctUpdateSeq; 
   unsigned short                   ServiceNum;
   unsigned char                    m_u1ServiceNumWeCarray;  
   
   unsigned short                   ServiceId[META_CMMB_SERV_BLOCK_NUM];          
   unsigned char                    FreqPointId[META_CMMB_SERV_BLOCK_NUM];       
   
}META_CMMB_SctStruct_T;

typedef struct  
{
   unsigned char                   EsgUpdateSeq;  
    
   unsigned char                   NetLevel;  
   unsigned short                  NetId;  
                           
   unsigned char                   LocalTimeOffset;                  
   unsigned char                   CharSet;
                              
   unsigned char                   EsgServiceNum;
   unsigned char                   m_ucEsgServiceNumWeCarry;  
   
   unsigned char                   EsgService_EsgServiceIndex[META_CMMB_BLK_NUM];   
   unsigned short                  EsgService_EsgServiceId[META_CMMB_BLK_NUM];    
   
                                         
   unsigned char                   EsgDataNum;  
   
   unsigned char                   m_ucEsgDataNumWeCarry;
   unsigned char                   EsgData_EsgDataType[META_CMMB_BLK_NUM];
   
   unsigned char                   EsgData_EsgDataBlockNum[META_CMMB_BLK_NUM];
   unsigned char                   m_ucEsgData_EsgDataBlockNumWeCarry[META_CMMB_BLK_NUM];
   
   unsigned char                   EsgDataBlock_EsgDataBlockId[META_CMMB_BLK_NUM][META_CMMB_BLK_NUM];             
   unsigned char                   EsgDataBlock_EsgDataBlockVersion[META_CMMB_BLK_NUM][META_CMMB_BLK_NUM];
   unsigned char                   EsgDataBlock_EsgServiceIndex[META_CMMB_BLK_NUM][META_CMMB_BLK_NUM];     
	
}META_CMMB_EsgListStruct_T;

typedef struct
{
	unsigned char             CaUpdateSeq;
    unsigned short            CaDataNum;
    unsigned char             m_ucCaDataNumWeCarry;
    unsigned short            CaId[META_CMMB_BLK_NUM];      
    unsigned short            ServiceId[META_CMMB_BLK_NUM];     
    unsigned char             EMM_BlockUnitType[META_CMMB_BLK_NUM];
    unsigned char             ECM_BlockUnitType[META_CMMB_BLK_NUM];
    unsigned char             ECM_TransmissionType[META_CMMB_BLK_NUM];
    
}META_CMMB_CaListStruct_T;

typedef struct
{
    
    META_CMMB_NitStruct_T        m_rNit;  

    META_CMMB_MctStruct_T        m_rCSmct[2]; // [0] for Cmct, [1] for Smct
   
    META_CMMB_SctStruct_T        m_rCSsct[2]; // [0] for Csct, [1] for Ssct

 
    unsigned char				   Eb_EbUpdateSeq;
    unsigned char				   Eb_EbMsgNum;
    unsigned short			       Eb_DataBlockLen;
    unsigned char				   m_ucDataBlockLenWeCarray;
    unsigned char				   Eb_DataBlock[META_CMMB_DATA_BLK_NUM];
  
  
    unsigned char                   m_ucHasEsg;  
	META_CMMB_EsgListStruct_T		m_rEsg;
	  
    
    unsigned char                   m_ucHasCa;
    META_CMMB_CaListStruct_T		m_rCa;
    
	
}META_CMMB_CtrlInfoTable_T;


typedef struct
{

	unsigned char                    m_u1NitUpdateSeq; 
	unsigned char                    m_u1CmctUpdateSeq;
	unsigned char                    m_u1SmctUpdateSeq;
	unsigned char                    m_u1CsctUpdateSeq;
	unsigned char                    m_u1SsctUpdateSeq;
	unsigned char                    m_u1EsgUpdateSeq;   
	unsigned char       			 m_u1FreqPointId;  
	
	
	unsigned char                    m_u1NetLevel;
	unsigned short					 m_u2NetId;
  
	unsigned char                    m_u1HasCtrlTable;  // 0: no, 1: yes
	META_CMMB_CtrlInfoTable_T        m_rCtrlTableInfo; 
	

}META_CMMB_FrameInfo_T;

typedef struct
{
    unsigned char                m_u1FrmNum;
	META_CMMB_FrameInfo_T        m_rFrmInfo[META_CMMB_FRAME_INFO_NUM];
	
}META_CMMB_AUTO_SCAN_CNF_T;

typedef struct
{
    unsigned char                m_u1FrmNum;
	META_CMMB_FrameInfo_T        m_rFrmInfo[META_CMMB_FRAME_INFO_NUM];
	
}META_CMMB_SET_FREQ_CNF_T;


typedef struct
{
	unsigned char m_u1FreqPointId;

}CMMB_SET_FREQ_REQ_T;

typedef struct
{
	unsigned char    m_u1FrmId;
	unsigned short   m_u2ServId;

}CMMB_SEL_SERV_REQ_ONLY_T;

typedef struct
{
	unsigned char    m_u1FrmId;
	unsigned short   m_u2ServId;
}META_CMMB_PAUSE_SERV_REQ_T;

typedef struct
{
	unsigned char   m_u1FreqPointId;
    char            m_i1Rssi;                 // unit: -dBm 0~100, 0 is best  , -1 means no such kinds of value
    char            m_i1Snr;                  // unit: dBm  0~100, 100 is best, -1 means no such kinds of value
    char            m_i1CurLdpcErrPercent;    // unit: %    0~100, 0 is best  , -1 means no such kinds of value

	int            m_i4TotalLdpcErrCnt;      // unit: -1 means no such kinds of value 
    int            m_i4TotalLdpcCnt;         // unit: -1 means no such kinds of value
    
    int             m_i4CurRsErrorCnt;    // -1 means no such kinkds of value
	int             m_i4TotalRsErrorCnt;  // -1 means no such kinkds of value
	 
}META_CMMB_GET_SIGNAL_STRENGTH_CNF_T;

/*

typedef struct
{
	unsigned char  m_u1TableItem;
	unsigned char  m_u1NetLevel;
    unsigned short m_u2NetId;
	unsigned char  m_u1FreqPointId;
	unsigned short m_u2ServiceId;
	 
}META_CMMB_GET_TABLE_REQ_T;


typedef struct
{
    unsigned char  m_u1TableItem;  // 0: NIT, 1: MCT, 2:SCT, 4:EB, 5:ESG_BASIC
    unsigned char  m_u1NetLevel;
    unsigned short m_u2NetId;
	unsigned char  m_u1FreqPointId;
	unsigned short m_u2ServiceId;

}CMMB_GET_TABLE_CNF_T;
*/


//--------------------------//
//      CMMB Functions      //
//--------------------------//
META_RESULT  __stdcall META_CMMB_TurnOn(const unsigned int ms_timeout);
META_RESULT  __stdcall META_CMMB_TurnOn_r(const int meta_handle, const unsigned int ms_timeout);
META_RESULT  __stdcall META_CMMB_TurnOff(const unsigned int ms_timeout);
META_RESULT  __stdcall META_CMMB_TurnOff_r(const int meta_handle, const unsigned int ms_timeout);
META_RESULT __stdcall  META_CMMB_SetBand(const unsigned int ms_timeout, const META_CMMB_SET_BAND_REQ_T *req);
META_RESULT __stdcall  META_CMMB_SetBand_r(const int meta_handle, const unsigned int ms_timeout, const META_CMMB_SET_BAND_REQ_T *req);
META_RESULT __stdcall  META_CMMB_AutoScanGetFreq(const unsigned int ms_timeout, META_CMMB_AUTO_SCAN_GET_FREQ_CNF_T *cnf);
META_RESULT __stdcall  META_CMMB_AutoScanGetFreq_r(const int meta_handle, const unsigned int ms_timeout, META_CMMB_AUTO_SCAN_GET_FREQ_CNF_T *cnf);

META_RESULT __stdcall  META_CMMB_AutoScan(const unsigned int ms_timeout, META_CMMB_AUTO_SCAN_CNF_T *cnf);
META_RESULT __stdcall  META_CMMB_AutoScan_r(const int meta_handle, const unsigned int ms_timeout, META_CMMB_AUTO_SCAN_CNF_T *cnf);


META_RESULT __stdcall  META_CMMB_StopAutoScan(const unsigned int ms_timeout);
META_RESULT __stdcall  META_CMMB_StopAutoScan_r(const int meta_handle, const unsigned int ms_timeout);
META_RESULT __stdcall  META_CMMB_SetFreq(const unsigned int ms_timeout, const CMMB_SET_FREQ_REQ_T *req, META_CMMB_SET_FREQ_CNF_T *cnf);
META_RESULT __stdcall  META_CMMB_SetFreq_r(const int meta_handle, const unsigned int ms_timeout, const CMMB_SET_FREQ_REQ_T *req, META_CMMB_SET_FREQ_CNF_T *cnf);

META_RESULT __stdcall  META_CMMB_SelServOnly(const unsigned int ms_timeout, const CMMB_SEL_SERV_REQ_ONLY_T *pSelServReq);
META_RESULT __stdcall  META_CMMB_SelServOnly_r(const int meta_handle, const unsigned int ms_timeout, const CMMB_SEL_SERV_REQ_ONLY_T *pSelServReq);
META_RESULT __stdcall  META_CMMB_PauseServ(unsigned int ms_timeout, const META_CMMB_PAUSE_SERV_REQ_T *req);
META_RESULT __stdcall  META_CMMB_PauseServ_r(const int meta_handle, unsigned int ms_timeout, const META_CMMB_PAUSE_SERV_REQ_T *req);


META_RESULT __stdcall  META_CMMB_GetSignalStrength(const unsigned int ms_timeout, META_CMMB_GET_SIGNAL_STRENGTH_CNF_T *cnf);
META_RESULT __stdcall  META_CMMB_GetSignalStrength_r(const int meta_handle, const unsigned int ms_timeout, META_CMMB_GET_SIGNAL_STRENGTH_CNF_T *cnf);


META_RESULT __stdcall  META_CMMB_AutoScanWithFreqRange(const unsigned int ms_timeout, META_CMMB_FREQ_RANGE_FOR_AUTO_SCAN_REQ_T *req, META_CMMB_AUTO_SCAN_CNF_T *cnf);
META_RESULT __stdcall  META_CMMB_AutoScanWithFreqRange_r(const int meta_handle, const unsigned int ms_timeout, META_CMMB_FREQ_RANGE_FOR_AUTO_SCAN_REQ_T *req, META_CMMB_AUTO_SCAN_CNF_T *cnf);


//===== Customized function ========================

META_RESULT __stdcall META_Customer_Func(int ms_timeout, const unsigned char *data_in, const int data_in_len, unsigned char *data_out, int *data_out_len);
META_RESULT __stdcall META_Customer_Func_r(int meta_handle, int ms_timeout, const unsigned char *data_in, const int data_in_len, unsigned char *data_out, int *data_out_len);


META_RESULT __stdcall META_Aux_Func(int ms_timeout, const unsigned char *data_in, const int data_in_len, unsigned char *data_out, int *data_out_len);
META_RESULT __stdcall META_Aux_Func_r(int meta_handle, int ms_timeout, const unsigned char *data_in, const int data_in_len, unsigned char *data_out, int *data_out_len);

// MATV functions
typedef struct
{
	unsigned int	freq;
	unsigned char	sndsys;
	unsigned char	colsys;
	unsigned char	flag;
}matv_ch_entry;

typedef struct
{
    unsigned char   m_ucChannel;
    matv_ch_entry   m_rmatv_ch_entry;
}FT_MATV_SET_CHANNEL_PROPERTY_REQ_T;

typedef struct
{
    unsigned char   m_ucProgress;
    unsigned char   m_ucChannels;
    matv_ch_entry   m_rmatv_ch_entry[70];
}FT_MATV_GET_CHANNEL_LIST_CNF_T;

typedef struct
{
    int             m_i4QualityIndex[128];
}FT_MATV_GET_CHANNEL_QUALITY_ALL_CNF_T;

META_RESULT  __stdcall META_MATV_PowerOn(unsigned int ms_timeout);
META_RESULT  __stdcall META_MATV_PowerOn_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_MATV_PowerOff(unsigned int ms_timeout);
META_RESULT  __stdcall META_MATV_PowerOff_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_MATV_SetRegion(unsigned int ms_timeout, unsigned char region);
META_RESULT  __stdcall META_MATV_SetRegion_r(const int meta_handle, unsigned int ms_timeout, unsigned char region);
META_RESULT  __stdcall META_MATV_StartScan(unsigned int ms_timeout, unsigned int scanmode);
META_RESULT  __stdcall META_MATV_StartScan_r(const int meta_handle, unsigned int ms_timeout, unsigned char scanmode);
META_RESULT  __stdcall META_MATV_StartFullScan(unsigned int ms_timeout);
META_RESULT  __stdcall META_MATV_StartFullScan_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_MATV_StopScan(unsigned int ms_timeout);
META_RESULT  __stdcall META_MATV_StopScan_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_MATV_GetChannelList(unsigned int ms_timeout, FT_MATV_GET_CHANNEL_LIST_CNF_T* cnf);
META_RESULT  __stdcall META_MATV_GetChannelList_r(const int meta_handle, unsigned int ms_timeout, FT_MATV_GET_CHANNEL_LIST_CNF_T* cnf);
META_RESULT  __stdcall META_MATV_ChangeChannel(unsigned int ms_timeout, unsigned char channel);
META_RESULT  __stdcall META_MATV_ChangeChannel_r(const int meta_handle, unsigned int ms_timeout, unsigned char channel);
META_RESULT  __stdcall META_MATV_SetChannelProperty(unsigned int ms_timeout, FT_MATV_SET_CHANNEL_PROPERTY_REQ_T* req);
META_RESULT  __stdcall META_MATV_SetChannelProperty_r(const int meta_handle, unsigned int ms_timeout, FT_MATV_SET_CHANNEL_PROPERTY_REQ_T* req);
META_RESULT  __stdcall META_MATV_GetChannelQuality(unsigned int ms_timeout, unsigned short item, int *qualityindex);
META_RESULT  __stdcall META_MATV_GetChannelQuality_r(const int meta_handle, unsigned int ms_timeout, unsigned short index, int *qualityindex);
META_RESULT  __stdcall META_MATV_GetChannelQualityAll(unsigned int ms_timeout, FT_MATV_GET_CHANNEL_QUALITY_ALL_CNF_T* channel_quality);
META_RESULT  __stdcall META_MATV_GetChannelQualityAll_r(const int meta_handle, unsigned int ms_timeout, FT_MATV_GET_CHANNEL_QUALITY_ALL_CNF_T* channel_quality);

// CCT
typedef struct{
	char sensor_prefix_name[64];
}CCT_Dual_Dev_ISP_camera_sensor_prefix_name_struct;

typedef struct{
	char lens_prefix_name[64];
}CCT_Dual_Dev_ISP_camera_lens_prefix_name_struct;


/*************************************************
 *============== Audio Ex Operation===============
 *************************************************/

#define META_L4AUD_VOL_TYPE_TONE 0 // Tone
#define META_L4AUD_VOL_TYPE_KT   1 // keytone
#define META_L4AUD_VOL_TYPE_MIC  2 // microphone
#define META_L4AUD_VOL_TYPE_FMR  3  // FM Radio
#define META_L4AUD_VOL_TYPE_SPH  4  // speech
#define META_L4AUD_VOL_TYPE_SID  5   // side tne
#define META_L4AUD_VOL_TYPE_MEDIA 6  // media
#define META_L4AUD_VOL_TYPE_TVOUT 7  // TV-out

#define META_L4AUD_PATH_UNKNOWN   0x00
#define META_L4AUD_PATH_RECEIVER  0x01
#define META_L4AUD_PATH_HEADSET   0x02
#define META_L4AUD_PATH_SPEAKER   0x04
#define META_L4AUD_PATH_DUAL      0x08
#define META_L4AUD_PATH_BT        0x10


#define META_L4AUD_PGA_BUF_AUDIO   0
#define META_L4AUD_PGA_BUF_VOICE   1
#define META_L4AUD_PGA_BUF_UNKNOWN 2
#define META_L4AUD_PGA_BUF_MIC     3


#define META_L4AUD_GAIN_TABLE_UNKNOWN   -1
#define META_L4AUD_GAIN_TABLE_PURE       0
#define META_L4AUD_GAIN_TABLE_RAW        1
#define META_L4AUD_GAIN_TABLE_N_LEVEL    2


typedef struct
{
	unsigned char  u1VolType; 
	unsigned char  u1PathType;  
	unsigned short u2SIdx; //start index: from 0
	unsigned short  u2EIdx; // end index
	bool           b_digital_gain_support; 
	char           i1BufType;
	unsigned char  u1ExtAmpType; //0/L1SP_EXT_DAC_BUF0(0x40)/L1SP_EXT_DAC_BUF1(0x80)
    char           i1GainTableType;  // 0: only 8 bits
	unsigned short u2BufLevel;
	unsigned short u2ExtAmpCtrlPointNum;
}ft_l4aud_ex_gain_table_info_T; 


#define AUDIO_EX_GAIN_TABLE_MAP_ENTRY_MAX_NUM 100

typedef struct
{
   unsigned char u1EntryNum; 
   ft_l4aud_ex_gain_table_info_T gain_table_info[AUDIO_EX_GAIN_TABLE_MAP_ENTRY_MAX_NUM];
}Audio_Ex_GainTableMap_CNF_T;

META_RESULT __stdcall META_Audio_EX_GetGainTableMap(const unsigned int ms_timeout, Audio_Ex_GainTableMap_CNF_T *cnf);
META_RESULT __stdcall META_Audio_EX_GetGainTableMap_r(const int meta_handle, const unsigned int ms_timeout, Audio_Ex_GainTableMap_CNF_T *cnf);

META_RESULT  __stdcall META_GetGainTable_Next(int find_handle);
META_RESULT __stdcall META_GetGainTable_GetDetailedInfo(int find_handle, 
														unsigned char *vol_type,
														unsigned char *path_type,
														unsigned short *s_idx,
														unsigned short *e_idx,
														char *main_title,
														int main_title_len,
														char *sub_title,
														int sub_title_len);
META_RESULT __stdcall META_GetGainTable_Close(int *p_find_handle);

META_RESULT __stdcall META_GetGainTable_Start(const unsigned int ms_timeout, int *p_find_handle);
META_RESULT __stdcall META_GetGainTable_Start_r(const int meta_handle, const unsigned int ms_timeout, int *p_find_handle);


typedef struct
{
	char   i1BufType;
	unsigned short  u2BufLevel;
}Audio_Ex_GetPgaGainMap_REQ_T; //ft_l4aud_get_pga_gain_map_T;

typedef struct
{
	unsigned char   u1ExtDac;
	unsigned short u2CtrlPoint;
}Audio_Ex_GetExtAmpMap_REQ_T; //ft_l4aud_get_ext_amp_map_T;


#define AUDIO_EX_MAP_ENTRY_MAX_NUM 1000

typedef struct
{
	unsigned short u2EntryNum;
	char  i1MapInfo[AUDIO_EX_MAP_ENTRY_MAX_NUM]; 
}Audio_Ex_GainMap_CNF_T;

typedef struct
{
	unsigned char  u1BitNum;
	unsigned short u2EntryNum;
	char  i1MapInfo[AUDIO_EX_MAP_ENTRY_MAX_NUM]; 
}Audio_Ex_ExtAmpGainMap_CNF_T;


META_RESULT __stdcall META_Audio_EX_GetPgaGainMap(const unsigned int ms_timeout, 
													Audio_Ex_GetPgaGainMap_REQ_T *req, 
												    Audio_Ex_GainMap_CNF_T *cnf);
META_RESULT __stdcall META_Audio_EX_GetPgaGainMap_r(const int meta_handle, 
													  const unsigned int ms_timeout, 
													  Audio_Ex_GetPgaGainMap_REQ_T *req, 
												      Audio_Ex_GainMap_CNF_T *cnf);

META_RESULT __stdcall META_Audio_EX_GetExtAmpGainMap(const unsigned int ms_timeout, 
													Audio_Ex_GetExtAmpMap_REQ_T *req, 
												    Audio_Ex_ExtAmpGainMap_CNF_T *cnf);
META_RESULT __stdcall META_Audio_EX_GetExtAmpGainMap_r(const int meta_handle, 
													  const unsigned int ms_timeout, 
													  Audio_Ex_GetExtAmpMap_REQ_T *req, 
												      Audio_Ex_ExtAmpGainMap_CNF_T *cnf);

typedef struct
{
    /// number of bits per field
	unsigned char  u1BitNum;
    /// number of entries
	unsigned short u2EntryNum;
    /// scale factor of each map entry (if scale_factor is 2, the value of map entry should be divided by 10^2
    unsigned char  scale_factor;
    /// map entries
	short          i2MapInfo[AUDIO_EX_MAP_ENTRY_MAX_NUM]; 
}Audio_Ex_ExtAmpGainMap_CNF_Ex_T;
META_RESULT __stdcall META_Audio_EX_GetExtAmpGainMapEx(const unsigned int ms_timeout, 
													Audio_Ex_GetExtAmpMap_REQ_T *req, 
												    Audio_Ex_ExtAmpGainMap_CNF_Ex_T *cnf);

META_RESULT __stdcall META_Audio_EX_GetExtAmpGainMapEx_r(const int meta_handle, 
													  const unsigned int ms_timeout, 
													  Audio_Ex_GetExtAmpMap_REQ_T *req, 
												      Audio_Ex_ExtAmpGainMap_CNF_Ex_T *cnf);

typedef enum {
   MEDIA_FORMAT_GSM_FR,
   MEDIA_FORMAT_GSM_HR,
   MEDIA_FORMAT_GSM_EFR,
   MEDIA_FORMAT_AMR,
   MEDIA_FORMAT_AMR_WB,
   MEDIA_FORMAT_DAF,
   MEDIA_FORMAT_AAC,
   MEDIA_FORMAT_PCM_8K,
   MEDIA_FORMAT_PCM_16K,
   MEDIA_FORMAT_G711_ALAW,
   MEDIA_FORMAT_G711_ULAW,
   MEDIA_FORMAT_DVI_ADPCM,
   MEDIA_FORMAT_VRD,
   MEDIA_FORMAT_WAV,
   MEDIA_FORMAT_WAV_ALAW,
   MEDIA_FORMAT_WAV_ULAW,
   MEDIA_FORMAT_WAV_DVI_ADPCM,
   MEDIA_FORMAT_SMF,
   MEDIA_FORMAT_IMELODY,
   MEDIA_FORMAT_SMF_SND,
   MEDIA_FORMAT_MMF,
   MEDIA_FORMAT_AU,
   MEDIA_FORMAT_AIFF,
   MEDIA_FORMAT_VRSI,
   MEDIA_FORMAT_WMA,
   MEDIA_FORMAT_M4A,
   MEDIA_FORMAT_WAV_DVI_ADPCM_16K,
   MEDIA_FORMAT_VOIPEVL,
   MEDIA_FORMAT_AAC_PLUS,
   MEDIA_FORMAT_AAC_PLUS_V2,
   MEDIA_FORMAT_BSAC,
   MEDIA_FORMAT_MUSICAM = 32,
   MEDIA_FORMAT_AWB_PLUS,
   MEDIA_FORMAT_AWB_PLUS_EXTEND,
   MEDIA_FORMAT_WAV_16K,
   MEDIA_FORMAT_MP4_AAC,
   MEDIA_FORMAT_MP4_AMR,
   MEDIA_FORMAT_MP4_AMR_WB,
   MEDIA_FORMAT_MP4_BSAC,
   MEDIA_FORMAT_DRA,
   MEDIA_FORMAT_COOK,
   MEDIA_FORMAT_APE,
   MEDIA_FORMAT_UNKNOWN
} Media_Format;

typedef struct
{
    /// format MEDIA_FORMAT_WAV_DVI_ADPCM (narrow-band), MEDIA_FORMAT_WAV_DVI_ADPCM_16K (wide-band)
    unsigned int   fmt;
    /// parameter (0: for MEDIA_FORMAT_WAV_DVI_ADPCM/MEDIA_FORMAT_WAV_DVI_ADPCM_16K)
    unsigned short param;
    /// requested time(ms)
    unsigned int   requested_time;
    /// [IN/OUT] file path of target (set all the buffer to NULL means the target will create file on its own)
    char           file_path[512];
}Audio_Ex_RecordingParam_T;

META_RESULT  __stdcall META_Audio_EX_StartRecording(unsigned int ms_timeout, const Audio_Ex_RecordingParam_T *param);
META_RESULT  __stdcall META_Audio_EX_StartRecording_r(const int meta_handle, unsigned int ms_timeout, const Audio_Ex_RecordingParam_T *param);

typedef struct
{
    /// file path of target
    char     target_path[512];
    /// file path of local
    char     local_path[512];
    /// get file from target or not
    int      get_file;
    /// delete target side file or not
    int      delete_file;
    /// progress callback
    CALLBACK_META_FAT_PROGRESS cb;
    /// stop flag
    int      stop_flag;
}Audio_Ex_StopRecording_T;

META_RESULT  __stdcall META_Audio_EX_StopRecording(unsigned int ms_timeout, const Audio_Ex_StopRecording_T * req);
META_RESULT  __stdcall META_Audio_EX_StopRecording_r(const int meta_handle, unsigned int ms_timeout, const Audio_Ex_StopRecording_T * req);

typedef struct
{
    /// requested time(ms)
    unsigned int requested_time;
    /// recorded time(ms)
    unsigned int offset;
}Audio_Ex_QueryRecording_T;

META_RESULT  __stdcall META_Audio_EX_QueryRecording(unsigned int ms_timeout, Audio_Ex_QueryRecording_T *status);
META_RESULT  __stdcall META_Audio_EX_QueryRecording_r(const int meta_handle, unsigned int ms_timeout, Audio_Ex_QueryRecording_T *status);

typedef struct
{
    unsigned char  u1SpeechModeNum;
    unsigned char  u1SpeechModeParaMaxNum;
    unsigned short u2ModeTitelBufLen;
    char*          i1ModeTileBuf;
}Audio_Ex_Speech_Mode_Table_CNF_T;

META_RESULT __stdcall META_Audio_EX_GetSpeechModeTable(const unsigned int ms_timeout, Audio_Ex_Speech_Mode_Table_CNF_T *cnf);
META_RESULT __stdcall META_Audio_EX_GetSpeechModeTable_r(const int meta_handle, const unsigned int ms_timeout, Audio_Ex_Speech_Mode_Table_CNF_T *cnf);
#ifdef __cplusplus
}
#endif

#endif
